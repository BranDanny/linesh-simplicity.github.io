[{"id":"2016-03-11-elegant-mac-iterm2","title":"Mac优雅的工具集——iTerm2篇","contents":"\n\n本篇是我Mac优雅工具集系列下其中的一篇文章，[原文全文](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)托管在Gitbook上，分享了Mac系统下一些使工作变得更高效的工具。\n\n# iTerm2实用特性 Handy Features\n\n这里的参考：[https://www.iterm2.com/features.html](https://www.iterm2.com/features.html)\n\niTerm这个终端具有比系统默认终端更强的能力，而term3则是最近刚发布的beta版本。它比起系统默认终端具备更加丰富且实用的功能，比如：\n\n* 窗口切分(Split Panes)\n* 即时窗口(Hotkey Window)\n* 搜索，支持正则表达式\n* 全键盘复制(Mouseless Copy)\n* 自动补全(Auto Complete)\n* 粘贴版历史记录(Paste History)\n* 即时回放(Instant Replay)\n* 触发器(Triggers)(虽然还不知道是什么鬼)\n* ...等\n\n\n## 窗口切分 Split Panes\niterm2支持把窗口进行横向纵向切分，自己可以调整占据的比例，并且不活跃的窗口（inactive panel）还会变暗以强调活跃的窗口，对于需要一个工作区间做多件事的需求是很有用的。\n\n![iTerm2-panes-split](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-panes-split.png)\n\n* 纵向切分：`Command+D`\n* 横向切分：`Shift+Command+D`\n* 窗口切换：`Command+[` / `Command+]` / `Option+Command+Left` / `Option+Command+Right`\n\n\n## 即时窗口 Hotkey Window\nhotkey windows让你在任何地方都可以打开终端执行一些命令，对我来说应用最多的场合，应该是在搜索一些问题的时候，对于一些需要输入命令的解决方案可以即时拷贝命令，打开终端来输入。比如，现在我在搜索“如何安装zsh语法高亮的插件”，然后找到了zsh语法高亮插件的官方github，一共有三个步骤，我可以立即就打开iterm2的hotkey window，拷贝git clone的命令拷贝仓库，再打开一个窗口用vim修改`~/.zshrc`文件的内容，然后`source`一下，高亮搞定！\n\n![iTerms2-hotkey-window](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-hotkey-window.png)\n\n* 全屏切换：`Command+Enter`。全屏模式切换在hotkey window下尤其顺滑，太赞！！\n* 窗口模糊度toggle：`Command+U`\n\n\n## 搜索与全键盘复制粘贴 Search and Mouseless Selection\n这个功能其实我不太常用，就是可以在iterm2窗口中搜索内容，跟在编辑器中搜索一样，支持正则表达式搜索。此外，还支持选中当前搜索内容一键复制等，功能强大，就是没怎么用到。\n\n![iTerm2-search-and-mouseless-selection](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-search-and-mouseless-selection.png)\n\n* 搜索：`Command+F`\n* 复制选中内容：`Enter/Return`\n* 拓展选择（反向拓展）：`tab/Shift+tab`\n\n\n## 自动补全与粘贴板历史 Autocomplete and Paste History\n只要是在终端输入过的词或者命令，iterm2就可以帮你提供自动补全的建议，快捷键是`Command+;`，调出后即可通过纯键盘输入来筛选，比较适合快速输入一些长命令，如下，其快捷键也比`Control+R`友好一点，可视化程度更高一些。在其他相似的场景下，这个功能有一些替代品，比如目录导航时使用autojump/z、搜索历史命令时使用`Control+R`、`history`等。\n\n另外，iterm2也帮你保存了你粘贴过的命令，通过快捷键`Shift+Command+H`即可调出，但仅限于通过粘贴板的方式进入的命令。\n\n![iTerm2-autocomplete](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-autocomplete.png)\n\n![iTerm2-paste-history](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-paste-history.png)\n\n\n## 即时回放 Instant Replay\n逆天功能，可以回放过去任一**时刻**里iterm窗口的状态，在你需要之前窗口的一些信息时特别有用，可以回过去查看。虽然我不怎么用到这个功能，但你知道出事了随时都可以回去查看以前的信息。快捷键是`Option+Command+B`，每个session的即时回放缓存默认是4MB，可以在设置里面改。\n\n\n## 智能选择 Smart Selection\niterm2能够只能识别邮件地址、URL、文件名、文件夹等名称，按住`Command`键点击即可去到相应的地方。比较handy，用处不小也不大。\n\n\n## 系统配置\n\n### 要打开的选项\n\n* General -> Closing -> Confirm 'Quit iTerm2' command。`Command+Q`离`Command+W/1/2/3/Tab`如此之近，保不齐你什么时候手一滑按错所有窗口就都归西了\n* Appearance -> Window -> Hide scrollbars。据经验基本没必要，没用的元素就不打开让它占据空间\n* Profiles -> Text -> Cursor: Underline, Blinking cursor，光标指示符采用下划线并且加闪烁效果。个人喜好\n* Profiles -> Text -> Font: 12pt Monaco，此字体甚好\n\n### 要关闭的选项\n\n* General -> Selection -> Copy to pasteboard on selection。选中即复制，这不烦人嘛\n* General -> Window -> Adjust window when changing font size。比较建议关掉，虽然调整字体大小的时候不常见，但若窗口大小跟着变又得调窗口大小\n* Appearance -> Tabs -> Show tab close buttons。有`Command+W`和`exit`就行了\n* Keys -> Navigation Shortcuts -> To switch split panes，关掉\n* Keys -> Navigation Shortcuts -> To switch windows，关掉\n\n\n## 快捷键\n除了上面提到的在一些场景下比较常用的快捷键，这里尽可能地要精简整个软件所使用的快捷键，其他不常用的能删都删了。\n\n* `Shift+delete`，打开hotkey window，这里更改了默认的配置，因为空格的组合其他程序都在用，比如`Control+Space`是Intellij的上下文提示，`Command+Space`是Alfred/Spotlight的全局快捷键，`Option+Space`是系统默认的幻灯片播放，`Option+Command+Space`被我也因为前面快捷键被占的原因被我定制成输入法切换，`Shift+Space`是输入法的简繁体切换。太难记了，所以hotkey window的快捷键不这么用\n* `Control+A/E`，系统默认的快捷键，师承vim系风格，分别是跳到行头/行尾的快捷键，在编辑的时候对效率有一定帮助\n* `Command+Up/Down`，上一行/下一行\n* `Control+U`，直接删掉一行"},{"id":"2016-03-13-elegant-mac-oh-my-zsh","title":"Mac优雅的工具集——oh-my-zsh篇","contents":"\n\n本篇是我Mac优雅工具集系列下其中的一篇文章，[原文全文](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)托管在Gitbook上，分享了Mac系统下一些使工作变得更高效的工具。\n\n# oh-my-zsh\n\n有了一个趁手的终端，大的功能就算有了，接下来是一些小的细节的优化，比如主题，自动补全，三方插件集成等。因为[oh-my-zsh](http://ohmyz.sh/)太过有名，为我节省了一些选择的时间，也就不需要再考察其他选择，用了再说。其主页的介绍也是相当不低调，说用上一个主题，马上就会被别人当成极客中的大神，过来围观问你这个主题这么漂亮是怎么配的。然后深藏功与名的你，马上就会在程序员中作为神话被广泛传颂。\n\noh-my-zsh的两大主要功能分别是：\n\n* **主題（themes）**\n* **插件（plugins）**\n\n## 工作目录与配置文件\n[首先需要安装一个zsh](https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH)，安装方法在此不详述请点击链接或查看官网。安装时需要提前装好`git`、`wget`或`curl`工具。\n\nzsh默认的安装位置是在`~/.oh-my-zsh`文件夹下，同时在你的根目录`~`下会有一个配置文件`~/.zshrc`，这个配置文件非常重要，我们的主题和插件都是在这个文件里面配。同时它做好一些准备工作后，会去调用`~/.oh-my-zsh/oh-my-zsh.sh`文件设置好启动zsh所需的所有路径、加载完主题和插件。这个脚本源码值得阅读，官方文档中提到的许多特性都在这个脚本中体现，比如定制自己的配置、主题和插件等时的目录约定、定制主题优先于默认主题的加载、空/随机主题的配置和加载、自动更新等。配置好`~/.zshrc`文件后，`source ~/.zshrc`一下即生效。\n\n\n## 主题 Themes\n所有的主题都在`~/.zshrc`脚本的`ZSH_THEME`一行中配置，个人喜好是使用`\"random\"`值，每次zsh启动时都会随机加载一个主题。所有的官方标配主题都放在`~/.oh-my-zsh/themes`文件夹中，也可以[前往官方wiki之主题篇查看效果](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)。另外目前官方已不接受更多的主题提交请求，所以用户自己定制的一些主题则要前往[External Resource](https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes)查看。\n\n![zsh-random-themes](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-random-themes.png)\n\n![zsh-random-themes-fino-time](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-random-themes-fino-time.png)\n\n\n## 插件 Plugins\n就我所了解，zsh的插件并不提供实质性的功能，比如`git`插件，并不会自带git的命令行工具。插件提供的更多的是**集成**和**alias**的功能，只是为了让你在终端能更好更快地使用它。当然也有一些提供了便捷功能的插件，比如目录自动跳转等。\n\n插件开启在`~/.zshrc`文件的`plugins=(git ...)`一行配置，加入插件名并以空格分隔即可。所有的插件都已经放置在`~/.oh-my-zsh/plugins`目录下了。下面推荐一些个人比较推荐的插件，更多的插件可以在[github的官方wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview)查询。\n\n\n### 自动跳转 Fast Jumping \n* `autojump`。没有结果预览，不太友好\n* `z`。UI非常友好，并且有多个结果时支持使用TAB键进行导航特点是刚开始用要先进去你的目录让它“学习”\n* `wd`。可以给特定的目录“注册”（`wd add name`）别名，然后直接输入别名即可进入目录，特点是只能跳转到已注册的目录。但支持键盘操作，属于…可有可无的插件\n\n目前题主我三个工具都启用了，但打算关闭autojump，因为觉得z的UI更加友好\n\n![zsh-plugins-autojump](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-autojump.png)\n\n![zsh-plugins-z](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-z.png)\n\n![zsh-plugins-wd](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-wd.png)\n\n\n### 更简短的快捷键 Alias\n* `git`。首推git插件，它提供的是一个**全球统一**的alias，只要是使用zsh的终端都可以使用同样的缩略命令，常用的有比如`gst` `gca` `gca!` `gcan!` `gup` `gp` `gcb` `gcf` `gcm` `gco`等，完整的命令列表可以参考[zsh-git github的官方wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git)\n  ![zsh-plugins-git](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-git.png)\n* `sublime`。使用统一的`st`命令启动sublime，为你屏蔽了sublime可能混乱的安装位置\n* `history`。提供了`h`代替`history`，提供了`hsi`命令来搜索带特定字符串的历史\n\n\n### 自动补全、搜索与语法高亮\n* [git-completion](https://github.com/git/git/blob/master/contrib/completion/git-completion.zsh)。git命令的自动补全\n* [zsh-completion](https://github.com/zsh-users/zsh-completions)。zsh命令的自动补全\n* [zsh-syntax-highlighting](https://github.com/zsh-users/zsh-syntax-highlighting)。简直美妙\n* [zsh-history-substring-search](https://github.com/zsh-users/zsh-history-substring-search)。简直美妙，其实我看不太出来哪些补全是哪个插件做的，总之一口气全部装上就对了。zsh的语法高亮插件会在你命令输错的时候变红，下面是总的效果图\n\n![zsh-plugins-complete-overview](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-complete-overview.png)\n"},{"id":"2016-03-17-a-module-require-confusion","title":"说开去——项目的JavaScript模块化实践（上篇）","contents":"\n\n> 为保护商业机密，本博客中出现的所有代码与文字均已隐去所有与客户相关的信息。若仍有泄露请第一时间联系博主我：linesh.simpcity@gmail.com。\n\n## 原生JavaScirpt也自带了模块化支持？\n起因是这样的，今天发现项目上的每个js文件基本都是这样的写法：\n\n```javascript\nmodule(\"module.name.bainianlaodian\", (function() {\n   function isValidRequest() {\n      // implementation;\n   }\n   return {\n      isValidRequest: isValidRequest\n   }\n}()))\n```\n\n然后在外部引用的时候只需要使用`module.name.bainianlaodian.isValidRequest()`就可以调用模块内的函数了，而且可以引用任意路径下的js文件。我就有点好奇，什么时候JavaScript有模块了？一般都是通过[IIFE](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)和闭包结合的方式来人为地创建一个“模块”，但并未看过这种直接调用的写法。而且引用时的路径是在哪里指定的？虽然靠猜也可以大概猜到，这个只需要通过维护一个全局的map记录模块名和对应的函数即可做到，不过还是挺有兴趣看一下具体的实现。于是问了一下项目组的同事，大家也表示不太清楚这个`module`及用法。那就`Ctrl+B`一下，看一下`module`这个变量的定义点吧，Intellij给出的提示是：\n\n```\nmodule (externs.js, src/main/webapp/.../bower_components/xdate/build)\nmodule (colors.js, node_modules/grunt/node_modules/colors)\nmodule (cli.js, node_modules/grunt-contrib-jslint/node_modules/jslint/node_modules/cli)\nmodule Window (qunit.js, src/main/webapp/.../bower_components/modernizr/test/qunit)\nmodule Window (qunit.js, src/main/webapp/.../bower_components/underscore/test/vendor)\n...\n```\n\n看着都不像，而且都是通过`npm`或者`bower`引进来的工具。我所期待的结果，应该是类似于nodejs或者类似的框架或环境所提供的变量和加载方式，类似于[这篇文章](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000)讲到的模块加载的方式。嗯，既然蛮干无用，那就求助一下程序员的~~好基友~~良师益友Google吧：\n\n### Google也解决不到的问题\n\n* `javascript module`\n* `jquery module`\n* `javascript module(\"\", function() {`\n* `commonjs module`\n* `nodejs module`\n* `amd javascript module`\n* `es5 javascript module`\n* `es6 javascript module`\n\n用以上的方式作为关键词，均没有找到什么有价值的线索。nodejs中虽然存在`module`这么一个变量，但是项目中的这些js代码没有在服务端执行的可能。Google了一下也没有发现是jQuery或者CommonJS规范里的内容，es6中有模块的概念，但使用的是`import`的关键词。这下可没有线索了，我更加怀疑这个`module`是项目里自己定义实现的了。但是从定义处入手并不能找到有价值的线索，那怎么办呢？既然IDE也无法给出有效的提示，那我就做一下人肉搜索咯，`Ctrl+Shift+F`全文搜索一下`module`这个关键词！过了两秒钟，IDE弹出一个对话框说\"1,001 occurrences found so far. Are you sure you wish to continue?\"额的神啊，看来这个刨根问底还真不容易，不过既然这是唯一的线索了，那果断还是要Continue的。于是我拍下了Continue，一共有7455处地方出现了`module`这个词。茫茫词海中，该如何捞到有价值的线索呢……？\n\n### 谜底水落石出\n\n有意思。由于搜索的名字太过宽泛，所以必然有很多不相关的结果，应该选择性忽略。比如`pom.xml`、`build.gradle`、`npm-debug.log`、test/`node_modules`/`bower_components`/java代码文件夹下的一切东西，最后发现了两个挺有可能相关的文件，一个在`laodian-libraries.generated.js`文件中，另一个在`js/common`文件夹下的一个`module.js`文件里。前者一看就是生成的代码，代码如下：\n\n```javascript\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n```\n\n看起来好像有点关系，其实并没有。这段代码是在做运行环境的检测，若是underscore是运行在服务端，就把`_`注册到`module.exports`变量中作为模块暴露出去；若是运行在浏览器端，则把`_`注册到全局对象`root`中去。这个`root`在某处其实也是被赋予全局变量`window`的值的。同时，这个文件也确实是打包生成的，打包是由`Gruntfile.js`中配置的`concat` task来完成的。真是又增长了知识。\n\n好消息是，在`js/common/module.js`这个文件里，我们似乎找到了想要的答案：\n\n```js\n(function(global) {\n\n  global.module = function registerModule(moduleName, moduleContent) {\n    var root = global;\n\n    if (moduleName.indexOf('.') == -1) {\n      registerToContext(root, moduleName, moduleContent);\n    } else {\n      var contexts = _(moduleName.split('.'));\n      var context = contexts.initial().reduce(function(memo, current) {\n        if (!memo[current]) {\n          memo[current] = emptyModuleObject();\n        }\n        return memo[current];\n      }, root);\n      // 这段代码会返回倒数第二个子模块，并为模块树中还不存在的子模块创建一个空的对象\n      // 并注册到其父模块中。优雅简洁的函数式编程，mind-blasting... [\"Mind Blasting\"][1]\n\n      registerToContext(context, contexts.last(), moduleContent);\n    }\n  };\n\n  function registerToContext(parentContext, moduleName, moduleContent) {\n    // 这个注册机制决定了新定义的模块不能覆盖已有的同名模块，而会直接被丢弃\n    var module = parentContext[moduleName];   \n    if (!module) parentContext[moduleName] = moduleContent;\n  };\n})(this); // this === window\n```\n\n**这套自定义的模块加载机制，它会将模块名解析成一个有包含关系的模块树，然后将所有模块及其之间的关系“注册”（其实就是加）到全局的`window`对象中。所有js代码对“模块”的引用其实都是在直接引用全局对象`window`下的变量，因此也无需配置具体的路径。**\n\n看到这里，一开始关于“模块的注册和运行机制”的问题似乎就完全清楚了。在浏览器中实际调试了一把还发现，`laodian-libraries.generated.js`是在`module.js`之前运行的。但是这里我发现了一个细节：实际被发送到客户端的js文件并不叫`module.js`，而是叫`laodian-basic.js`。搜索了一下`module.js`，**竟没有被引用的地方！**这让我不仅又想探索一个问题：这个js究竟是在什么地方被include到页面上的？什么时候被include进来？发布前又被做了什么操作？作为一个基础设施型的js，应该是每个页面都需要的，那么项目上是采用什么方式来实现这个事情的？\n\n欲知后事，请听[下文](#/posts/2016-03-21-javascript-package-compress-template-and-reuse)分解。\n\n---\n\n[1]： [https://www.youtube.com/watch?v=vtKdNT7o858](https://www.youtube.com/watch?v=vtKdNT7o858)        \"Russell Peters: Mind-Blasting Joke\"\n"},{"id":"2016-03-21-javascript-package-compress-template-and-reuse","title":"说开去——项目的JavaScript模块化实践（下篇）","contents":"\n\n> 为保护商业机密，本博客中出现的所有代码与文字均已隐去所有与客户相关的信息。若仍有泄露请第一时间联系博主我：linesh.simpcity@gmail.com。\n\n## 再次出发\n\n在这个说开去系列的[上篇](#/posts/2016-03-17-a-module-require-confusion)中，我们已经回答了项目自带的模块化的实现，同时也带出了更多的问题，总结起来有以下这些。它们是本篇视图回答的问题：\n\n* `module.js`是如何被打包到`laodian-basic.js`中去？\n* 我们找到的这个js是在什么地方被include到页面上的？\n* 什么时候被include进来的？\n* 项目上用了什么方式来复用include这个js的那段代码？\n\n### 如何打包？\n上面我们还留下了一条线索：`laodian-basic.js`。既然`module.js`没有被引用的地方，那么就搜索下`laodian-basic.js`的引用点。这里我看到了两个引用点：\n\n1. ```jawr.js.bundle.laodian.id=/bundles/laodian-basic.js```\n2. ```<laodian:script bundle=\"/bundles/laodian-basic.js\" useVersionNumber=\"true\" />```\n\n看来似乎是配置了一些东西，然后直接在前端jsp(咦前端jsp怎么听起来怪怪的)通过`jsp tag`来引用。其中，第一个文件位于一个`jawr.properties`文件下，第二个文件的目录结构如下图所示。\n\n![brand-specific-jsp-directory-structure](http://7xqu8w.com1.z0.glb.clouddn.com/a82b64e24b984d2a92c0c39397481825.png)\n\n百年老店的项目有一个特点，就是支持多品牌，同一套代码需要服务不同地区的用户。我们挑了一个服务于大英地区的文件`british.jsp`，`Alt+F7`之，不能找到它的引用点。如我们第4点所要探索的问题所指出，由于要支持多品牌多页面，这个文件可能最终是通过这样的形式来被使用的：`<%@ include file=\"${brand}.jsp\" %>`（手动反射）。这个目前还没有太多线索，那么先看看第一条线索，Google一下[jawr](https://jawr.java.net/index.html)：它是一个可配置的、支持共用开发与发布代码的JS/CSS文件压缩与打包工具。配置简单：\n\n```java\njawr.js.budnle.laodian-basic.id=/bundle/laodian-basic.js\njawr.js.budnle.laodian-basic.child.names=laodian-pages\njawr.js.budnle.laodian-pages.mappings=/js/laodian-pages/**/*.js\n```\n\n看到上面这段代码就很清楚了，jawr会把`/js/laodian-pages/`文件夹下的所有js文件打包到`laodian-basic.js`文件中。JAWR其实还有一个`JawrServlet`，它会去读取`jawr.properties`(在`web.xml`文件的`init-param`配置`configLocation`)中的配置，并且拦截所有匹配`/js/*`的路径。\n\n\n### js是如何被引用到页面上的？——SiteMesh\n从上面搜搜到的这段代码已经可以看出，`laodian-basic.js`这个文件是在`british.jsp`中被引用的，后者引入了大量的CSS/JS/FAVICON等文件，似乎是一个入口文件，但它却没有再被其他文件引用：\n\n```html\n<head>\n  <script type=\"text/javascript\" src=\"laodian/common/js/laodian-libraries.generated.js\"></script>\n  <script type=\"text/javascript\" src=\"laodian/common/js/bootstrap.generated.js\"></script>\n  <home:script bundle=\"/bundles/laodian-basic.js\" useVersionNumber=\"true\" />\n\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"laodian/british/css/british-specific.less\" />\n</head>\n\n<body id=\"${activePage}\" class=\"${activePage}\">\n  <decorator:usePage id=\"specific-page\" />\n  <div class=\"page\">\n    <header class=\"Header\">...</header>\n    <main id=\"main-wrapper\">\n      <decorator:body />\n    </main>\n    <footer class=\"Footer\">...</footer>\n  </div>\n</body>\n```\n\n笔者眼尖，看到了`<decorator>`这个标签。它是SiteMesh框架定义的一个标签，sitemesh是一个分离页面内容和展现（presentation）的轻量级框架，其设计中运用了四人帮的装饰模式。Google Trends了一下它的热度，以及与它同类型的一些产品/框架的趋势，如下图，看起来似乎都要挂了。sitemesh3/tiles分别已经1/2年没维护了，只有wicket还在持续对Java8增加支持。这是不是意味着它所依附的模板技术也差不多日暮西山了？而模板技术又是前后端难以分离的一个重要的点，其实也从侧面印证了前后端分离的大趋势吧。\n\n![Trends-jsp-freemarker-etc](http://7xqu8w.com1.z0.glb.clouddn.com/f366e36a7e197a73e0b3cb46c563658d.png)\n\n![Trends-sitemesh-tiles-etc](http://7xqu8w.com1.z0.glb.clouddn.com/0b4e597eb0f1fba6eefa6c0d774e0961.png)\n\nAnyway不要跑题，火速看一下sitemesh的[文档](http://wiki.sitemesh.org/wiki/display/sitemesh/Setup+SiteMesh+in+5+Minutes+or+Less)，寻找启动项目的配置文件：`decorator.xml`！搜索一下项目的对应配置文件，果然有。看它的配置文件：\n\n```xml\n<decorators defaultdir=\"/WEB-INF/decorators\">\n  <decorator name=\"master-decorator\" page=\"main.jsp\">\n    <pattern>/british</pattern>\n    <pattern>/america</pattern>\n    <pattern>/...</pattern>\n  </decorator>\n</decorators>\n```\n\n这段代码在向我殷殷诉说：从特定路径下来的页面请求都会被`main.jsp`文件所前置装饰，再看到`main.jsp`文件：\n\n```java\n...\n<%\n  try {\n    String target = getLocale();\n    request.getRequestDispatcher(\"/WEB-INF/decorators/\" + target + \".jsp\")\n      .include(request, response);\n  } catch (...) {\n%>\n```\n\n这段代码也验证了我们一开始的判断，即我们是通过类似`${locale}.jsp`的形式来引用目标jsp文件的。至此所有实现都已经很清楚了：**通过SiteMesh对所有待渲染页面进行装饰，根据不同的地区分配到不同的`${locale}.jsp`模板去，后者再开始加载框架性（module模块化实现等）代码，最后渲染一般的html/js/jsp(template)。**\n\n## 总结与思考 Further Thinking\n\n许多时候一个项目的框架已经搭好，我们在使用的时候很少不会接触框架性的部分，比如js/css的压缩加载过程、多品牌的处理、框架选型等。既要写好业务代码，对于技术代码框架代码也要多了解，学会自己选型、搭脚手架。本文上篇讨论的其实是模块化的问题，下篇话题擦了模板技术的一点皮毛。深挖下去，还有许多问题可以了解：\n\n* 模块化的现状与实现。包括吕立青在[这里](http://blog.jimmylv.info/2016-03-10-getting-webpack-done-and-js-module-history)提到的一些相关技术或规范：CommonJS/AMD/WebPack/Browserify/NodeJS等\n* 模板技术。模板技术是依托于后端技术选型的，在选型的时候必须考虑现有的技术构架和迁移成本。另外在讨论模板技术孰优孰劣之前，也有必要先思考一下它所依托的后端框架的发展现状，比如Spring的生态圈（MVC/Boot)，比如是否必须要用Java来写后端代码等\n"},{"id":"2016-03-28-quick-coding-bibles","title":"唯快不破——快速编码实践","contents":"\n\n# 必先正名 —— 何谓快\n\n在谈论快之前，有必要先讨论一下何谓快。我的定义是，快不是速度快，而是效率高。当然许多场景下，速度快了效率自然就高。“效率高”又有两个延伸问题需要定义：\n\n* **做何事的效率？也即“快”的目标**，比如我要你2分钟洗5个梨，你说我洗10个苹果只需要1分钟，这种快跟目标不合就没用\n* **为何要高效率？**\n\n总结了一下半年多来的工作经验，我认为软件行业暂不讨论与人相关的因素下，技术工作需要具备三个能力：基础能力、快速构建能力、工程能力。这三项不在本文仔细展开，其中快速构建能力是指就一个项目需求或实际的工具需求，能使用已有知识和工具快速搭建出可工作的原型的能力。本文的快，（可能狭义地）认为是这种 快速适应项目或搭建应用 的快。\n\n为何要高效率。为节省出时间和脑力，以获得学习更多东西的机会。像挣更多钱这种大~~俗~~实话这里就不说了，好歹也是一枚文艺青年不是……【捂脸】\n\n# 快速编码笔记\n\n要在已有项目上完成添加或修改工作，不同的人可能有不同的方式。这里说说上了项目后学到的一点，即是采用 **直接定位修改点** 的方式。相比起了解整个系统的流程与工作原理，它更快，也更直接，是短平快的工作方式，有其学习的价值。对系统从头到尾的架构和细节了解，是课外的功夫，也有经验和积累，属于程序员的自我修养。因为我自己是~~处女座~~对原理更感兴趣的性格，在面对问题的时候会想先探究是如何实现的，有时就会阻碍学习或者解决问题的进度。这种不问为什么的理念，我觉得是个很好的补充。\n\n## 快速解决问题小笔记\n\n总结起来，在 **不问为什么，直接定位出错/修改地点** 的理念下，产生了一些直接但有效的实践，与我所见闻有很大关联，仅是学习笔记和抛砖引玉。这部分欢迎各种补充：linesh.simpcity@gmail.com。\n\n1. **看日志/控制台的输出信息，直接定位到问题发生的地点(controller, js, html element, etc...)**  \n  如果不知道日志的位置，可以观察项目的目录结构，或者跟踪Logger代码中的路径\n\n2. **GDT-Google Developer Tools的元素查看(Inspect elements)**  \n  可以通过id或class等特性有针对性地找到特定的元素，并借此搜寻作用于其上的绑定(比如jQuery、css等)\n\n3. **查看类或接口的所有实现(Command+Option+B in Intellij)**  \n  这里也是只能靠猜测的地方.但凡接口的实现必然有注入的地方，但在注入点到我们的调试点中间链可能很长，这样，只能通过找寻接口所有可能的实现，根据项目的实际情况，猜测_**注入发生的地点**_和_**被注入的实际类型**_，直接找到注入类，忽略中间过程。\n\n  **深入思考：**\n\n  接口提炼意味着所有可能被注入的对象存在着逻辑上（软件架构上，而非字面上）的联系。这里的实现，可能是指类或接口，也可能是字符串，其他类型的东西。实际的注入方式可能有以下几种：\n  * **字符串拼接**。这种情况说明待拼接串具有字面上的相似性（通常也反映了逻辑上的相似性），只是简单的文本填充。但其本身作为解耦的字串，可能暗示了其更高层使用者之间存在的逻辑联系。\n\n  * **反射**。我的毕设专题。它不同于手动声明对象的方式，它把“声明对象（包含为其申请内存，构建一个对象的过程）”这个动作从语言层面再次解耦出去。\n\n  * **混合使用**。其实这两种方式在Java中是以某种联系紧密连接的。字符串是反射特性使用的解耦符。它实现解耦的目的达到，在反射技术整个发展路上来看，这个技术的使用也是利大于弊的，但它也是有缺点的。抛开性能缺陷不说，它实现解耦的方式是把应用层的问题下放到语言层（虚拟机层），这样语言层面的代码可读性就消失了，你调试的难度就要增加。\n\n4. **spring mvc的RequestMapping注解找映射路径**\n\n5. **通过服务器(Tomcat, Jetty等)的配置文件找访问路径**  \n  只要路径不是自动生成，最终都是组织到配置文件来解决的节奏。\n\n6. **观察依赖管理工具的配置文件来看其引入的依赖**  \n  项目常用的管理工具有：\n  * 前端开发工具依赖管理npm(package.json)\n  * 前端开发库依赖管理bower(.bowerrc, bower.json)\n  * 前端任务构建管理grunt(gruntfile.js)\n  * 后端依赖管理maven(pom.xml)\n  * 后端任务构建管理gradle等。\n\n7. **CVS日志找某个特性的开发人**\n\n8. **Intellij的全文搜索**\n  全文搜索其实还是有一些技巧，根据前面采集到的一些有标志性的信息来进行搜索，今天看到子建还可以用`>Policy Holders<`这样的方式来搜索一个HTML标签等。多观察多学习。\n\n9. **网上资源库，一些可能有集中的相关context的人分享的平台，比如confluence**\n\n10. **前端UI/JavaScript相关可以在控制台Google Developer Tools中直接像素级调整/观察资源加载/调试等**\n  前端是个有趣且发挥想象力的地方，页面上的东西都是所见即所得，工作方式比较粗暴，要什么样式先直接在GDT里面调，像素级别地加减。\n\n## 慢即是快\n\n那么最后，与直接定位到问题所在的思维/解决方式不同的另外一种方式，是直接走通整个流程。这种方式通常更为可视化，理解更为透彻，也更花时间。但在尝试了所有能快速解决的方式仍不能成功的情况下，不能说这种方式就是慢。意在解决问题，而困难问题的解决，偏是需要耐心和智慧的。棋道术语曰“后中先”。常用的方法有：\n\n1. **经典的debug功能**\n\n2. **直接把整个程序跑起来**  \n  比如在做Java反射的时候，最为直观的方式就是把虚拟机build起来。\n\n## 查找一切 Google Everything \n好的，如果上面的方法依然不足以找到你需要的东西怎么办呢？把上面搜到的东西作为关键词，再采用其他的方式（如google）来进行链式搜索。Google乃是泛指，只要能搜到，管你是用什么工具（谢谢AlphaGo狗哥）。唯快不破，粗暴之美。\n\n## 总结与反省 Conclusion\n\n其实在快这个问题上，不妨认为“快”也只是其中的一种方式，不应拘束在术中，发现了好的方法能够提高效率，都该使用。另外，对为什么“快”的认知在学习的过程很重要，需要认清所需。不是一味追求快，以至对有时停步的思考都感到焦急。\n\n本篇侧重在技术的编码上，在其他方面还有很多习惯可以使我们的工作变得更快，比如：\n\n* 提高手速\n* 熟悉快捷键\n* 善用英文和搜索引擎\n* 使用markdown写作\n* 专注时间\n* 趁手的编辑器（sublime/vim/emacs等）/软件（Alfred/……没了）等\n\n对于工具这个专题，我 [自己也在写一些总结，托管在Gitbook上](https://www.gitbook.com/book/linesh/gitbook-elegant-mac-tools-system-closure/details)，尚未写完持续更新中，有兴趣的读者可以过来参阅。\n\n\n\n"},{"id":"2016-06-23-spring-mvc-documentation-reference","title":"Spring MVC官方文档翻译稿发布","contents":"\n\n这份翻译终于大概可以发布第一版可读的原型。几天在国内一些网站推广了一下，有点分散，于是决定在大本营这里放一份完整的发布稿，相当于是官方声明了，哈哈。既然是官方声明，那么官方这里倒是可以给点bouns，说说翻译过程的想法，以及最近一些情况。\n\n首先以下是发表在[OSC](http://my.oschina.net/u/1581831/blog/700769)/[CSDN](http://blog.csdn.net/codecleaner/article/details/51758452)/[Iteye](http://sodagreen-simplicity.iteye.com/admin/blogs/2307252)/[博客园](http://www.cnblogs.com/natasha-yarovenko/p/5616369.html)/[掘金](https://gold.xitu.io/entry/576e56962e958a00572bdb38/detail)/[v2ex](http://www.v2ex.com/t/288717#reply34)/[segmentfault](https://segmentfault.com/a/1190000005854194)/[Githuber](http://ask.githuber.cn/t/spring-mvc-4-2-4-release/1539/1)上的原文。\n\n\n> ![](http://7xqu8w.com1.z0.glb.clouddn.com/spring-logo.png)\n>\n> 前后经过九个月，我翻译的Spring MVC官方4.2.4版本中文文档可以发布第一个较为完整的版本了。译文上尽量做到准确并且符合中文习惯，让人能读懂，能理解。现全文发布如下，也希望它能够给出其价值，并收到反馈。\n>\n> * 七牛主站：[mvc.linesh.tw](http://mvc.linesh.tw)\n> * 备份镜像：[一个奇怪的域名](http://7xvpsh.com1.z0.glb.clouddn.com/)（主站不稳定时使用）\n> * [Gitbook原站](https://linesh.gitbooks.io/spring-mvc-documentation-linesh-translation/content/)（墙内访问较慢，且不太稳定）\n>\n> 阅读过程任何想法、建议、吐槽、强迫症~~不给译者狂点100个赞就浑身不舒服~~、觉得赞、觉得不赞，无论关于翻译、技术、样式等，请让我知道。你可以：\n>\n> * [来Github赞我~~被消费一个~~](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation)\n> * 在Gitbook讨论里[给我留言](https://www.gitbook.com/book/linesh/spring-mvc-documentation-linesh-translation/discussions)\n> * 在Github里给这个项目提[issue](https://github.com/linesh-simplicity/gitbook-translation-spring-mvc-documentation/issues)\n> * 在Github里给这个项目提[pull request](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation/pulls)\n> * [在文档上进行即时评论](http://mvc.linesh.tw)：在gitbook文档上，鼠标划过任何段落右侧，浮现`+`号时点击即可评论\n> * 邮箱：linesh.simpcity@gmail.com\n>\n> ![](http://7xqu8w.com1.z0.glb.clouddn.com/spring-mvc-documentation-translation-project-snapshot.png)\n>\n> ## 翻译过程，文本无关的思考\n>\n> 在翻译上仍在摸索，有自己的想法，体现到译本中，读者也许可以发现一些痕迹。这种种理念，如果要排个优先级，那么我觉得是：\n>\n> 1. 符合中文习惯。看起来像机翻不能要，名词乱翻误导读者不能要，长句复杂句太多不能要\n> 2. 准确传达原意。这点原本是最重要的，但让位于符合中文习惯，是因为如果译本有机翻痕迹，给人的品质感和可信度就降低了\n> 3. 更准确和更优雅的翻译风格。\n>\n> 软件开发的脚步一直在前进。发展尤其火和快的应数前端，各式样的MV*框架（Angular/React/Vue.js）、包管理（npm/bower）、构建工具（webpack/gulp/grunt）不胜其数，展示了前端所见即所得的强大魅力。与这股前后端分离趋势相适应的呢，后端也在提RESTful、MicroService这些东西。我对后端感兴趣，也希望能克服一些不舒适去学习前端的东西，一些UI实在使人愉悦。\n>\n> 另外呢，翻译和推广翻译又是两回事。翻译的时候自然希望译文受到大家喜欢和关注，但昨天在各大平台推广的时候呢，又发现什么样的题目和图片能更吸引读者眼球。后端在社群里相对前端确实没有那么可视化，很多模式、框架、架构等讨论起来流于文字，要是还不注重UI和representation的话，确实光看到题目就直接pass掉了。在活跃的社区呢，也看到了一些现象，大家现在想要看什么东西？\n>\n> * 从Android代码中来记忆23种设计模式\n> * 15款你可能不知道的精致Mac应用\n> * 100个弹框设计小结\n> * 5款高效的原型设计工具\n> * [Android名企面试题及涉及知识点整理](https://github.com/Mr-YangCheng/ForAndroidInterview)\n>\n> 资源太过丰富，导致我们学习浅尝辄止，这已经是一个许多人提过的问题。看到有人为我们总结了几点几点，一下就看完了，或者集合了什么资源，下意识点个赞，收藏一下（特别是还有这种[收藏插件](https://chrome.google.com/webstore/detail/better-bookmark/pniopfmciclllcpockpkgceikipiibol)），就完了。点赞收藏的成本很低，但这样确定不是在朝着抵抗力最低的路径在走吗？不是在放弃自己思考的权利么？难道不是在成为被平台消费的用户？看完了这些东西，我真的就提高了吗？\n>\n> 我反省的恰是这个。Bob Martin在《程序员的自我修养》一书中说，“那些在过去50年中来之不易的理念，绝大部分在今天仍像过去一样富有价值，甚至宝贵了”。在翻译的过程，我对MVC和Spring所提供的AOP、IOC、设计模式，以及Servlet 3.0规范一些东西，感觉有深挖的价值。里面是一些更为根本的代码功底和工程理念，非表层框架变迁所及。\n>\n> 推广之初，本是希望这个译本能被多多star，反省及此，又希望自己不要被消费，同时希望各位不要被我所消费。什么是有有益的，什么是自己需要的，什么工具能让自己更有效率，就去看，去用。其余形式应无所住。\n>\n> 以上。如此译本亦将脱离我而去。\n>\n> -- 2016年06月28日\n\n这个翻译项目从2015年9月份最早开始，中间停产了3个月，端端续续更新了1个月后，中间又停产了3个月左右，后来不知道为什么，又产生了坚持下去的偏执。所以最主要的部分都是半个月前翻出来的。这样的作息严格来说其实不太健康，不过最近一段时间在技术学习选择上出现了一点小迷惘，因此没事给自己找事情做，我觉得也无可厚非。而且，这个阶段并非全无价值。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/spring-mvc-documentation-contribution-traffic.png)\n\n入职11个月~~我真的没有在数日子~~，感觉上是进入了一个舒适区，项目、技术，和反馈。这个译本初稿的完成，其实也是我想对这段时间做个告别，重新出发。翻译项目会进入维护阶段，每天有一点规律的时间来维护。除此以外，在这个迷惘的过程中，似乎也渐渐对自己的定位有了一些思考，对想做什么，要做什么，也因此可能有了一些想法。\n\n~~以下内容纯属想太多~~\n\n逐渐发现，IT行业的工作里，我们所聊“技术”，其指向可能不同。尤其公司所需的技术与个人喜欢的技术有时并不重合，至少对我来说不甚重合。这其间关系与重叠自不赘述，但基本学习方向会分为企业级技术和个人技术来学。接下来主要的事情有：\n\n* **速度和基本功**。主要是规律、刻意地练习打字、快捷键、TDD、code kata。熊叔叔说的好，这些东西内化成下意识，才能更高效地思考其他\n* **professionalism**。项目上，作为一名ThoughtWorker的专业，要继续修炼\n* **企业级开发**。主要是想学习Java、Spring MVC/Boot、DevOps、Angular、React等构建稳定、可伸缩的企业系统的技术能力\n* **个人开发**。对于个人项目而言，最有用的莫非 **数据** 和 **展示** 两方面。因此，一些轻量级的语言工具会很有助益。这一块我想学有JavaScript、CSS（做展示）、脚本、Python（写爬虫）、CI（持续集成），以及一些提高效率的工具\n* **行业业务**。比如现在客户的业务，就可以刻意学习提高\n"},{"id":"2016-06-26-auto-deploy-translation-to-production-using-jenkins-and-qiniu","title":"我是如何进行Spring MVC文档翻译项目的环境搭建、项目管理及自动化构建工作的","contents":"\n\n> 感兴趣的同学可以关注这个[翻译项目](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation) 、 [我的博客原文](http://blog.linesh.tw/#/posts/2016-06-26-auto-deploy-translation-to-production-using-jenkins-and-qiniu) 和 [我的Github](https://github.com/linesh-simplicity)\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/spring-mvc-translation-project-home-page-version-2.png \"Final website of MVC translation project\")\n\n前段时间翻译的 Spring MVC 官方文档完成了第一稿，具体的地址可以访问[这里](http://mvc.linesh.tw)。这篇文章主要是总结一下这个翻译项目自开始到上线发布一个完整的生命流程，内容包括**翻译环境搭建**、**项目管理**与**自动化构建**三部分。\n\n## 环境搭建\n\n开始一个翻译项目，有多少事情需要我们去考虑呢？你可能会想到，一个好的编辑环境、一个组织文档章节的软件、一个漂亮的界面等……这些最终都是需要的。但是，不要忘记，最重要的出发点只有一个，就是**马上开始翻译**。工具、样式，在一开始的时候，我们希望它以轻盈的姿态出现在我们的面前，既要有最简单的 setup，又要在后面我们对项目进行管理、构建和自动化时有足够好的支持。\n\n慢着，你说文档翻译的工作需要管理我还能理解，毕竟它是一个项目嘛，项目需要管理，这我能理解。不过…一个翻译项目还需要构建？还需要自动化？有啥好构建的？不急，这部分我会在后面慢慢道来。现在，我们先来看看，为了得到一个最顺手的翻译环境，我们需要进行一些什么基本配置。\n\n开始翻译，我们希望直接进入内容本身，开始将一行行英文翻译成中文。这个是最核心的诉求。当然，也有一些其他的需求，比如章节间联系与组织、调调样式等。但我们不希望在开发（翻译）的时候将这些职责耦合进来，本着单一职责原则，我们把这些翻译以外的事务交给工具来处理。总结下来，一个趁手可扩展的环境应该包含：\n\n* markdown\n* 编辑器（Sublime/Atom 等）\n* 版本管理（Git）\n* 代码托管平台（Github）\n* 章节管理工具（Gitbook）\n\nmarkdown 让你的世界纯粹得只有翻译，相反你不会想在 Word 中一边翻译一边调行间距；Git 是持续集成之魂；Github 作为最大的平台提供了最丰富的资源；而 Gitbook 会帮你处理章节组织以及样式渲染，使得你可以快速开始。\n\n### Markdown\n\nMarkdown是一种近乎完美的写作标记语言，其最大的功劳便是将写作从内容中分离出来，这个分离使你只专注于写作内容本身而不需关注内容最终的样式，极大地提高了效率及工作愉悦度。反例是 Microsoft 的 Word，你不会想一边翻译，一边调整行间距，然后接着翻译，翻了几段以后又移动鼠标将小节的标题加粗。如此往复，不仅翻译的这个思考过程（mindset）被打断，整个精神和注意力也无法集中，效率与质量也就可想而知了。\n\n比如说，上面这段文字在markdown中写出来是这样的：\n\n```\n## 环境搭建\n\n……本着单一职责原则，我们把这些翻译以外的事物交给工具来处理。总结下来，一个趁手可扩展的环境应该包含：\n\n* markdown\n* 编辑器（ Sublime/Atom 等）\n* 版本管理（Git）\n* 代码托管平台（Github）\n* 章节管理工具（Gitbook）\n\n专注于内容之所以能提高效率，因为它将翻译与写作从样式中解放了出来。你不想在 Word 中一边翻译一边调行间距。Git 是持续集成之魂……\n```\n\n说起来markdown这个名字也有点意思，一般的标记语言叫markup language。这里将up改成down，寓意着将标记语言中与内容本身无关的标记全部剔除，形成一个精简子集。本篇不是markdown用法记，不会详细介绍，具体可参考以下链接：\n\n* [Wikipedia: Markdown](https://en.wikipedia.org/wiki/Markdown)\n* [Markdown overview](https://daringfireball.net/projects/markdown/)\n* [Github上最有名的Markdown Cheat Sheet仓库](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)\n\n### Markdown编辑器\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/atom-as-translation-project-editor.png \"Use Atom as the translation project's editor\")\n\n编辑器的选择并无定式，打造一个符合自己操作习惯的编辑器也是每个程序员自己的一个工作，这里我不赘述。在Mac上，不错的markdown编辑器有Sublime 3、Atom、MacDown、Mark Editor等，可挑选适合自己的，我选择的是Atom，是因为有一个刚性的需求它能够满足：\n\n* **与终端（terminal）的集成**\n\n由于使用了版本管理，同时有时有拷贝文件、查看目录等需求，命令行肯定是必须随时在手的。终端方面我的选择是iTerm2+zsh，关于它们的配置和特性，可以查看这两篇文章 [Mac优雅的工具集——iTerm2篇](http://blog.linesh.tw/#/posts/2016-03-11-elegant-mac-iterm2) 和 [Mac优雅的工具集——oh-my-zsh篇](http://blog.linesh.tw/#/posts/2016-03-13-elegant-mac-oh-my-zsh)。对如何在Mac上构建一个优雅的工具集有兴趣的同学，也可以前往Gitbook看看我正在写的这个系列：[关于优雅地使用Mac OS的理念、想法、工具与实践集](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)。\n\n### 版本管理 Git\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/git-logo.png \"Git Logo\")\n\nGit作为版本管理的意义也不赘言，要做持续集成、版本回滚必须要有一个 vcs。你肯定不想自己的工作区最后变成这样：\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/word-as-version-manager.jpeg \"Word As version control will suck\")\n\n对于 Git 还不是很熟悉的同学可以参考下面我给出的链接了解。另外，zsh下的Git可以配一下自动补全，加上它自带的 git 插件，相当于一个全球通用的 alias。具体配置非常简单，可以来[这里](http://blog.linesh.tw/#/posts/2016-03-13-elegant-mac-oh-my-zsh)看一下最终的效果。\n\n* [Git - 简易指南](http://www.bootcss.com/p/git-guide/)\n* [廖雪峰的官方网站：史上最浅显易懂的Git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/)\n* [A Visual Git Reference](http://marklodato.github.io/visual-git-guide/index-en.html)\n\n### 代码托管平台 Github\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/github-homepage.png \"Github Homepage\")\n\nGithub是 ~~世界上最大的同性交友平台~~ 一个代码托管平台，有着繁荣的生态圈和平台资源。在这个平台上，我可以给翻译项目一个`README.md`文件，为阅读的人做简单的介绍以及引流，同时它可与CI、Gitbook等工具完美集成，其内置的issue、pull-request功能还能与Zenhub结合，直接当成trello来进行项目管理之用。相关的工具下一节会介绍。\n\n### 写书专用工具 Gitbook\n\n上文提到了翻译内容与样式的分离。实际上在这里样式这部分就是由Gitbook自带的渲染引擎来负责的。此外，Gitbook还能帮助你管理整个书的目录结构、章节生成、搜索、词汇表、站点构建与生成等，同时它也有较为丰富的插件生态。这一切只需要你进行少量的配置。其低学习成本与高效益，使它成为了我进行翻译编排首先的工具。\n\n你只需要在书的根目录下运行`gitbook init`命令，它就会生成下图所示的一个目录结构：\n\n```\n.\n├── README.md\n└── SUMMARY.md\n```\n\n## 项目管理\n\n项目管理方面的需求，主要是有时会有想法出现，希望增加什么特性，或者想到什么问题不想马上修，那么最好是有一个TODOLIST可以随时记录下来，并且能被方便地检索到。这方面的需求，怎么解决呢？\n\n### issue + zenhub\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/zenhub-as-issue-tracker.png \"Use Zenhub As Issue tracker\")\n\nGithub内置的issue功能已经好用到爆，再加上专为Github issue功能定制的[Zenhub](https://www.zenhub.com/)简直就是活生生把issue当成trello来用。一些内置特性如下，稍加体验即可满足所有小型项目管理上的需求：\n\n* issue可以通过commit sha直接与相关的单次提交关联，还可以 [通过提交信息来引用、关闭issue](https://help.github.com/articles/closing-issues-via-commit-messages/)\n* issue中支持GFM(Github Flavored Markdown)，可以直接使用todolist的语法\n* 通过Command/Ctrl+V可以直接在留言中上传截图\n* 可以为issue添加标签（tag）、类别（pipeline, 如正在做、还没做、已完成等）\n* 可以为issue估点、指定负责人、燃尽图，简直就是为敏捷实践而生，不过在这个翻译项目中用不到这些，毕竟自己给自己估点没什么意思\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/github-flavored-markdown-todolist.png \"Github flavored markdown todolist\")\n\n## 自动化构建\n\n自动化什么的构建？这还要从本翻译稿的托管平台——Gitbook——说起。gitbook是一个绝好的写作平台，官方也通过Webhooks提供了与Github的集成，只要你把代码`git push`到远端仓库，Gitbook就会自动拉取仓库中的内容，按照特定的格式为书本构建站点。过大概2到3分钟，你就可以在[Gitbook](https://linesh.gitbooks.io/spring-mvc-documentation-linesh-translation/content/)上看到自己最新的更新已经到书上了。一切看起来都十分美好，一键提交与部署。但是有一个最大的问题：**Gitbook在国内的速度不行，轻则卡顿，重则整站被墙刷不出页面**。\n\n这种情况下，我决定将整个翻译同时迁移到七牛上。七牛的CDN在国内速度名声在外，用来托管静态站点再好不过~~只需要拍两张身份证正反双面的照片上传等待审核即可~~。迁移也很简单，因为gitbook生成的静态站点其实就是`_book`文件夹，只需要把这个文件夹下的全部东西放到七牛空间上去，在使用`index.html`作为入口就可以了。但是，问题又来了：\n\n* 七牛网站上无法上传文件夹。就算可以，我也无法忍受每次都要手动将文件夹拖上去\n* 每次仓库有更新，都需要将最新的内容同步到七牛空间上，并覆盖旧版本的同名文件\n* 第二步的操作还不能通过githook+shell的方式来做，因为整个过程的耗时会使`git push`的反馈周期变长，从而使得我更不倾向于频繁提交，影响翻译体验\n\n解决方案也很简单：\n\n* 第一条，寻找七牛的[SDK](http://developer.qiniu.com/resource/official.html#tool)，通过命令行进行上传\n* 第二条，既然不能，[细想]也没必要在本地做，那么就在远端做好了。远端在哪里呢？ **CI/Pipeline** 啊，这样构建站点、同步文件等工作都可以并行进行了，既不会阻碍本地开发速度，也不是翻译时需要考虑的问题，我还是只需要像以前一样`git push`提交代码即可，站点从构建到最终上线，都有CI在负责\n\n想法出来了，在实施的时候还是走了一些弯路的。这些折腾过程在此无法深表，只有可能带过~~程序员们都懂的~~。在CI的选择上，我选择了Jenkins 2.0，原因比较纯粹，最近项目上在使用Jenkins 2.0，我刚好当是练手。至此文章成笔之时，我仍在考察其他选择，比如travis-ci，看起来UI和配置都简单许多，这部分可能是后文了。下面会简单介绍~~折腾~~搭建Jenkins 2.0作为本翻译项目CI的步骤和关键节点。\n\n### Jenkins下载、安装与启动\n\n话说Jenkins不愧为CI/CD领域的先锋，这个产品每周都会发一个小版本（目前最新是2.11）。Jenkins 2.0的安装，可以通过直接下载安装包的方式下载，在Mac上也可以通过`brew install jenkins`来下载安装。安装完成后，运行`jenkins`即可在`localhost:8080`启动一个本地的jenkins。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/jenkins-pipeline-home-page.png \"Jenkins home page\")\n\n### 注册一个七牛开发者账号\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/qiniu-home-page.png \"Qiniu Home Page\")\n\n流程十分简单，免费用户可以有一个空间，有一定的流量限制，不过通常来说对于只有一个空间需求的用户来说，这样的流量应该不会超吧。由于我已经超过了一个空间的需求，同时我又有配置独立域名的需求，所以需要更多的权限。流程也很简单，进行实名认证、填写身份证、上传本人及身份证正反面照片各一张~~本人不需拍反面~~，最后保证账户里有最少10元即可。\n\n### Jenkins：新建一个类型为pipeline的项目\n\npipeline搭建起来了，接下来我们需要捋一捋前面说到的两个步骤：构建站点、上传站点文件到七牛空间。细分下来，主要是有以下的task要做：\n\n* 引入必要的依赖\n* 构建站点\n* 同步到七牛\n\n#### 使用NPM，引入gitbook/gitbook-cli/qiniu\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/npm-home-page.png \"Npm home page\")\n\n我们想要构建站点，必然使用gitbook的命令行工具；要使用七牛的命令行，也必然引入相应的工具。这里我走过一些弯路，比如尝试将七牛工具以插件形式引入到Jenkins job中来，但是2.0以后，我们更倾向于使用脚本来描述构建工作，而非将Jenkins单纯当作一个转存/转储的工作区间并为该workspace零散地写一些适配脚本。因此，在pipeline类型的项目就不存在每个job特定的配置空间，若想使用插件，配置起来有些麻烦。于是，最后我决定使用七牛的npm包（肯定是有的），并通过NPM来管理所有依赖。以下是一个`package.json`文件需引入的依赖：\n\n```json\n{\n   ...\n   \"devDependencies\": {\n        \"gitbook\": \"^3.1.1\",\n        \"gitbook-cli\": \"^2.3.0\",\n        \"qiniu\": \"^6.1.11\"\n    },\n    ...\n}\n```\n\n另外，需要注意的是，Gitbook的渲染引擎已经升级到v3.1.1版本，与Legacy v2.6.7版引擎相比，主要的区别是[v3支持多个部分(part)的文章](https://github.com/GitbookIO/gitbook/blob/master/docs/pages.md)、默认关闭了目录中章节前的数字等。其中multipart的部分有些[小bug](https://github.com/GitbookIO/gitbook/issues/1301)但还可以忍受，但是默认关闭的目录数字则需要通过以下的配置给设置回来。在`book.json`文件中：\n\n```json\n{\n   \"gitbook\": \">=3.1.0\",\n   \"pluginsConfig\": {\n      \"theme-default\": {\n         \"showLevel\": true\n      }\n   }\n}\n```\n\n#### 构建站点\n\n简单地运行命令`gitbook build`即可生成站点目录。最后的构建脚本[Jenkinsfile.groovy](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation/blob/master/Jenkinsfile.groovy)如下所示：\n\n```groovy\nnode ('main') {\n    stage 'Pull latest changes from SCM'\n    git([\n        url: 'git@github.com:linesh-simplicity/translation-spring-mvc-4-documentation.git',\n        branch: 'master'\n    ])\n\n    stage 'Download dependencies: Gitbook/Gitbook-cli/Qiniu'\n    sh 'npm install'\n\n    stage 'Build book serving directory through Gitbook'\n    sh 'gitbook build --gitbook=3.1.1'\n\n    stage 'Upload production _book to Qiniu through their API'\n    sh './jenkins/sync-book-to-qiniu.sh'\n}\n```\n\n#### 上传文件到七牛\n\n使用七牛的命令行工具进行文件上传，需要配置一些东西，主要是要同步的本地目录、七牛的Access key和Secret Key等，示例代码则可以从七牛SDK的官网上参考。我最后完成的这份同步脚本[sync-book-to-qiniu.js](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation/blob/master/jenkins/sync-book-to-qiniu.js)如下所示，其中完成了 **准备本地同步目录** 、 **排除不同步文件** 、 **指定覆盖上传策略** 等工作：\n\n```js\nconst qiniu  = require(\"qiniu\");\nconst glob   = require('glob');\nconst crypto = require('crypto-js')\n\nconst ignoredFiles = [\n    'Jenkinsfile.groovy',\n    'sync-book-to-qiniu.js',\n    'sync-book-to-qiniu.sh',\n    'mvc-origin.md',\n    'package.json'\n];\n\n// node ./jenkins/sync-book-to-qiniu.js $ACCESS_KEY $SECRET_KEY\nconst qiniuAccessKey = process.argv.slice(2, 3);\nconst qiniuSecretKey = process.argv.slice(3);\n\n// Prepare Qiniu configuration options\nqiniu.conf.ACCESS_KEY = qiniuAccessKey.toString(crypto.enc.Utf8);\nqiniu.conf.SECRET_KEY = qiniuSecretKey.toString(crypto.enc.Utf8);\nconst bucket = 'mvc-linesh-tw';\n\nglob.sync('_book/**/*.*', {}).filter(filename => {\n    for (let ignored of ignoredFiles) {\n        if (filename.endsWith(ignored)) return false;\n    }\n    return true;\n}).forEach(filepath => {\n    const resource_key_in_qiniu_api = filepath.substring('_book/'.length, filepath.length);\n    // ':' means allow override upload. For further details refer to offical API docs\n    const policyToken = new qiniu.rs.PutPolicy(bucket + \":\" + resource_key_in_qiniu_api).token();\n    uploadFile(policyToken, resource_key_in_qiniu_api, filepath)\n})\n\nfunction uploadFile(uptoken, key, localFile) {\n    let extra = new qiniu.io.PutExtra();\n    qiniu.io.putFile(uptoken, key, localFile, extra, function(error, response) {\n        if(!error) {\n            console.log('[Success] File uploaded: ' + response.key);\n        } else {\n            console.log(error);\n        }\n    });\n}\n```\n\n同行们求review代码啊～\n\n### 避免提交七牛的AK和SK\n\nAK(Access Key)和SK(Secret Key)是七牛分配给注册开发者的一对密钥，不能泄露，否则其他人得到了就可以对你的七牛空间进行任意操作。但是，你要把构建工作自动化，就必须这段脚本提交到github上，同时CI还要能从你的代码中读出正确的AK和SK，这要如何做到呢？回答是，通过CI提供的接口，由pipeline将参数注入到你的代码中。这样，AK和SK就被保存在了pipeline上，别人无权对其进行访问。在Jenkins CI上，这是通过一个[EnvInject插件](https://wiki.jenkins-ci.org/display/JENKINS/EnvInject+Plugin)来做到的，在travis-ci中则更加简单，直接设置。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/jenkins-envinject-plugin.png \"Jenkins EnvInject Plugin\")\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/travis-ci-env-setting.png \"Travis CI environment variables settings\")\n\n### 使用travis-ci进行自动化构建\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/travis-home-page.png \"Travis home page\")\n\n——本小节为2016-07-06日添加\n\n如今我已经把本项目的构建从Jenkins迁移到travis-ci上去了，原因是travis-ci是一个online的CI，界面更漂亮，配置也更为容易。在构建步骤上，与通过Jenkins的构建大同小异：\n\n* 设置好必要的环境（node.js, npm等，因为Jenkins是在本地跑，不存在这些问题，travis上需要小配，也非常简单）\n* 通过npm安装必要的依赖（qiniu，gitbook等，也简单，跑一下安装即可）\n* 通过gitbook将站点目录构建出来\n* 配置好加密的AK/SK，并在构建脚本中获取\n* 将构建目录上传到七牛\n\n大部分步骤与使用Jenkins时并无二样。与Jenkins的JOB模型不同的是，travis整个核心的构建阶段只有两个：`install`和`script`，即安装依赖和执行脚本。每个阶段都有前后的拦截点，你可以在前后做些必要的操作。此外，对于依赖安装，travis还提供了缓存的功能。只需要在项目下放置一个`.travis.yml`文件即可触发整个构建。这个脚本的核心部分大致如下，没有中文注释，代码自注释：\n\n```\nlanguage: node_js\nnode_js:\n    - '6.1'\ncache:\n    directories:\n        - node_modules\nbefore_install:\n    - npm install -g gitbook-cli\ninstall:\n    - npm install\nscript:\n    - gitbook build\n    - ./travis/sync-book-to-qiniu.sh\n```\n\n另一个问题是AK和SK的问题，在Jenkins的方式是通过环境变量(env variables)的方式注入。不过现在travis不在本地，不敢这么玩了，虽然travis也提供了环境变量的注入，但毕竟把AK/SK上传到travis的服务器上了。好在travis提供了加密API，即你可以在本地先加密你的AK/SK，然后将这个加密后的值上传到配置文件中。travis执行构建的时候自动帮你解密回来，同时其他人也无法看到你的敏感数据。具体命令如下：\n\n```\ntravis encrypt \"ACCESS_KEY=value_without_bash_escape_characters\" --add\ntravis encrypt \"SECRET_KEY=if_there_is_special_characters_you_need_to_escape_them\" --add\n```\n\n## 总结\n\n![](http://7xvpsh.com1.z0.glb.clouddn.com/running-jenkins-pipeline.png \"Running jenkins pipeline\")\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/travis-upload-final-success-view.png \"Travis final success view\")\n\n呼呼，最后看到这个图的时候还是很激动的，所有的部署工作都成功了。那么也是时候结束了，本篇文章总结起来，讲了三方面的内容：\n\n* 如何准备和搭建让翻译工作更加专注和高效的环境和工具，如markdown/atom/gitbook/git/github等\n* 如何使用github的issue和zenhub来辅助管理翻译项目中的待办事项和协作\n* 如何使用CI工具Jenkins/travis将整个站点的构建和发布自动化，提高翻译和部署效率\n\n\n—— 2016-07-01\n\n## Bonus：Marketing\n\n哎呀bonus，其实说不清是彩蛋还是坏蛋了，主要是聊聊文章和推广吧。一开始推广的时候是地毯式地发，与吕靖所发平台有略微不同。发的平台有 [OSC](http://my.oschina.net/lineshtw/blog/704441) / [CSDN](http://blog.csdn.net/codecleaner/article/details/51808331) / [Iteye](http://sodagreen-simplicity.iteye.com/admin/blogs/2308678) / [博客园](http://www.cnblogs.com/natasha-yarovenko/p/5634661.html) / [掘金](https://gold.xitu.io/entry/5777f8395bbb50005948d9bb/detail) / [v2ex](http://www.v2ex.com/t/289735) / [segmentfault](https://segmentfault.com/a/1190000005858229) / [Githuber](http://ask.githuber.cn/t/spring-mvc/1547)一共8个地方，再后来便对此事有所厌倦，感觉短短两天让我的状态一直是在坐等点赞，真是需要戒断的欲望。\n\n不过，还是从各个平台的推广当中初步学习到推广的一些细节和方法论，以便日后推广时有的放矢，节约精力。方法论总结起来，有4点；小细节总结起来，有其他3点。\n\n### 方法论\n\n* **流量分析**。通过数据可以拿到不同平台带来的流量差别，从而不同平台可以有不同的推广力度，合理分配资源\n* **用户质量与数据**。视文章内容不同、平台偏好题材不同、平台主流用户不同，推广带来的效果也不同。所谓“效果”，可以浏览数、浏览时间、点赞数、评论数、相关链接点击数等数据来衡量\n* **自动化发布**。第一点中提到的平台差异，其实有一点伪命题。如果能拿到各个平台发布、修改文章的API，再通过自动化的方式一键发布、推广到各个平台，则人力成本可以忽略不计\n* **马太效应**。仓库越多人点赞，点赞的人质量越高，说明越靠谱，用户点赞的阻力也越小\n\n方法论利于用户分析，但不要走投机取巧的路子（但知道了至少想投的时候能投投）。专注于自我提升与内容质量本身，而非其他厚薄。在方法论方面，phodal有一些文章可供参考\n\n* [如何提高影响力](https://www.phodal.com/blog/how-to-improve-impact/)\n* [程序员如何提高影响力2.0](https://www.phodal.com/blog/improve-impact-2/)\n* [什么样的文章受欢迎](https://github.com/phodal/beautiful-content/blob/gh-pages/chapters/chapter1.md)\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/my-marketing-platforms-and-bandwidth.png)\n\n从上图看，主要的流量还是来自掘金和v2ex，掘金的流量是直接导到七牛的主站。至于用户质量、有效的目标群体等仍无法知晓，但至少是一个推广的好去处。\n\n就编辑体验来讲，OSCHINA/CSDN两个平台支持markdown编辑~~哪个平台不支持markdown~~，前者还能自动生成目录，界面进行过改版，比以前有较大提升，但细看还是丑。从流量上看，OSCHINA贡献了一小块流量~~OSC上给人浓浓的圈子感我就不说了~~，CSDN则似乎不能帮忙推荐首页，文章发了两天，浏览量还是一位数。对于尚未建立平台和品牌的个人程序员来说，要获取流量似乎比较困难。\n\niteye和博客园，两个网站都不支持用markdown编辑，要先在其他地方用markdown here转一次再copy过来，遑论其他手动编辑方法的效率。iteye的流量大概是OSChina的三倍左右，三小丢丢；博客园发布了两天，浏览量一位数以内。\n\nsegmentfault是我用过样式最好的网站，有目录，markdown渲染样式稳重不浮夸，可惜流量也不多。还有其他一些推广网站，比如githuber/百度知道等，流量都非常小。\n\n### 小细节\n\n* **吸引人的题目**。资讯辣么多，你平时浏览会怎么办？是不是先看题目抓不抓人，筛选出有兴趣的文章？除了被消费，我们似乎也没有更好的办法。下面列出了一些常用的题目模式\n    * _我是如何xxx的_\n    * _xxx的38个xxx（技巧、平台、工具、网站）_\n    * _xxx，看这一篇就够了_\n    * _xx屌丝的xx逆袭_\n    * _15年编程生涯，资深架构师总结的7条经验_\n* **图片**。一定要有一个封面图片，不需要内容非常相关，只要让人看了有食欲就行。这是另一个主题，无需多加发挥\n* **目录**。很多时候，可能没什么兴趣看完你的整篇文章，只要被标题吸引进来了，这时有一个目录（如[OSC](http://my.oschina.net/u/1581831/blog/704441)和[segmentfault](https://segmentfault.com/a/1190000005858229)）明明白白指示文章结构，粗略滚动一下屏幕，如果看着图片又多，排版又好，内容也不差，点个赞，存个书签，表示到此一游了，就可以关掉页面点击下一个了\n* **资源收集类**。比如一些awesome-list，资源收集、网站收集，点个赞，收藏个书签\n\n其实小细节我觉得都反映出的是一个问题，就是看文章对于我们来说似乎已经变成一种阻力极小的习惯，我们更倾向于在碎片时间进行这种更加轻松不用动脑的阅读，安慰自己时刻在学习，但其实并没有进行深入阅读的心境，长期而言，被消费的其实是我们的时间和思考能力。如何应对？以我为主，网络和平台都只是工具，真正核心在自己所爱所想。去坚持，去生活，把时间给自己，给爱的人，就足够了，别没事晒照片逛论坛了。\n\n—— 2016-07-03\n"},{"id":"2016-07-20-elegant-mac-intellij-shortcuts","title":"Mac优雅的工具集——Intellij快捷键","contents":"\n\n本篇是我Mac优雅工具集系列下其中的一篇文章，[原文全文](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)托管在Gitbook上，分享了Mac系统下一些使工作变得更高效的工具。\n\n> 在线的精简cheatsheet备查表：[intellij.linesh.tw](http://intellij.linesh.tw)  \n> Github项目：[intellij-mac-frequent-keymap](https://github.com/linesh-simplicity/intellij-mac-frequent-keymap)\n\n# Intellij Cheatsheet：成吨提高Java编程开发效率\n\nIntellij的快捷键多而繁杂，处女座的我这一年里，拉拉杂杂也阅读了大量的文档和资料，从[官方推荐的keymap](https://resources.jetbrains.com/assets/products/intellij-idea/IntelliJIDEA_ReferenceCard_mac.pdf)到市面能看到的大多数资料和总结。结合平时的工作和个人项目经验，我尝试整理并总结其中最精华的部分，并通过这个子集总结思考与提高效率相关的思维模式和理念。于是有了这篇博客。总的来说，它讲了两个内容：\n\n* 快捷背后的理念与思维模式\n* 一套精简的Intellij快捷键核心子集\n\n产出的价值大概有这么几方面：\n\n* 一个[在线的cheatsheet备查表](http://intellij.linesh.tw)\n* 总结了高效快捷键的一个精简子集，节省了阅读其他杂而价值不高的快捷键的时间与精力\n* 总结了快捷背后的两个思维模式的转变：**更高层级的抽象** 和 **声明式使用**\n\n## 理念与思维模式\n\nIDE与电脑作为工具，永远是高效完成特定工作的辅助。因此我们所谓的高效有了上下文：以完成工作为主，在这个过程工具的作用是辅助工作。那么，所谓高效也即是问，如何更专注于工作本身，更高效地完成工作呢？在一系列落地的快捷键背后，这个围绕快捷键所展开的工作系统，其实质性提高工作效率的理念和思维模式本身是什么呢？我的回答是：\n\n* 更高层次的抽象\n* 声明式使用\n\n### 更高层次的抽象\n\n更高层次的抽象，指的是从代码、从语言本身特性的层面思考编程，而非单纯的文本或者字符串。要把思维从“把这五行代码剪切并复制到一个新的方法里”等把代码当成无意义字符的低层面活动，转变到以作为语言核心的要素和特性为单位的思考，比如类、变量、方法、重命名、重构、if-else、循环、可循环元素等。\n\n在这方面，IDE提供的 **Live Template**、**重构(Refactoring)**、部分后向声明等，都是这种思想的产物，允许你从更高的层级（语言特性、与Java高相关的重构）来思考代码，并尽量多地向上屏蔽细节。\n\n### 声明式使用\n\n声明式使用，指的是直接使用你完成工作所需要的元素（类、字段、方法等），让IDE为你自动补全缺少的声明或定义。这种思想同样贯穿这本工具集的始终，以更语义化（更高阶）的操作来使用工具。\n\n在这方面，IDE提供的 **后向声明(Postfix Auto Completion)**、**自动补全(Auto Completion)** 等，都是这种思想的产物。你不需要关注操作所在的上下文，IDE会为你补全，你需要关注的是工作和操作本身。\n\n\n## 快捷键精简子集\n\n本节主要分七个部分展开总结：生产力大杀器、语言要素生成、编辑、导航、重构、搜索、运行时。版本控制的部分未录入，原因是我倾向于使用命令行提交，而非IDE内置VCS支持。见仁见智。最后一栏是该操作在IDEA中的操作名称，可以在keymap中检索对应的action/shortcut找到。\n\n### 生产力（Productivity）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---      |:---:        |:---:          |:---     |\n| 模板补全 | ⌘+J | 插入一个符合某结构特征的模板，详解见下 | Insert live template |\n| 命令查询 | ⇧+⌘+S | 以名称的形式查询某个操作或快捷键，是声明式编程思想的完美体现 | Find actions |\n| 意图预测与智能帮助 | ⌥+Enter | 简单重构、移除死代码、结构调整、自动导包等| Show intention actions |\n\n#### 模板补全（Live Template）\n\n敲完以下模板补全的keyword之后可以直接通过tab或回车触发模板补全，$1/$2...是需要你填充的模板变量。\n\n| Operation | Mac OSX 10.5+ Keyword | Expands to | Comments |\n|:---: |:---: |:---: |:---: |\n| 判空 | `ifn` | `if ($1 == null) {}` | 后向声明也有同样功能，读者可拣顺手的用 |\n| 判非空 | `inn` | `if ($1 != null) {}` | |\n| 创建索引循环 | `fori` | `for (int $1 = 0; $1 < $2; $1++) {}` | |\n| 添加TODO | `todo` | `// TODO: $1` | 非常声明式的用法 |\n| 添加Fixme | `fixme` | `// FIXME: 7/19/16 $1` | 同上 |\n| 类型关系判定 | `inst` | `if ($1 instanceof $2) {} ` | |\n| System.out | `sout` | `System.out.println($1); `| 必须入手的黑技能，调试打log的时候非常有用 |\n\n#### 后向声明（Postfix Completion）\n\n[后向声明](https://blog.jetbrains.com/idea/2014/03/postfix-completion)是JetBrains系IDE的一项新功能，旨在减少光标经常性的前后移动，提高开发效率，形成这样的编程思维：先使用元素，再考虑变量声明或结构补全。它的主要功能是根据当前元素的属性，提供可能的行为建议，例如使用if-else结构包围、判（非）空、格式化、进行类型转换等。因此，后向声明所能提供的选择视元素（主要是变量）的不同而不同。\n\n所有元素都拥有的一些后向声明选择，仅选择我认为常用的：\n\n| Operation | Postfix Completion Keyword | Expands To | Comments | \n|:---: |:---: |:---: |:---: |\n| 变量声明 | element.`var` | `Type $name = element;` | 必备技能，声明式使用的典范 |\n| 转换为类字段 | element.`field` | `private $Type element; ` | 刚发现的 |\n| 将当前变量打印到输出流 | element.`sout` | `System.out.println(element);` ||\n| 返回当前值 | element.`return` | `return element;` | |\n| 类型转换 | element.`cast` | `(($Type) element)` | |\n\n然后，对于特定的元素类型，有的后向声明还有非常实用的选项，比如字符串的判空、布尔值的if-else、列表的循环等等：\n\n| ElementType | Operation | Postfix Completion Keyword | Expands To | Comments | \n|:--- |:---: |:---: |:---: |:---: |\n| 字符串 | 判空 | string.`null`| `if (string == null) {}` | |\n| | 判非空 | string.`notnull` | `if (string != null) {}` | |\n| 整数 | 分支 | int.`switch` | `switch (int) {}` | |\n| 布尔值 | 如果为真 | boolean.`if` | `if (boolean) {}` | |\n| | 如果为假 | boolean.`else` | `if (!boolean) {}` | |\n| | 反义 | boolean.`not` | `!boolean` | |\n| 列表 | 循环元素 | lists.`for` | `for (Type element : lists) {}` | 非常常用 |\n| | 带索引循环 | lists.`fori` | `for (int i = 0; i < lists.size(); i++) {}` | |\n\n\n### 编辑（Editing）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 基本代码补全 | ^+Space | 一般都用这个补全，变量命名时及方法补全时常用 | Code/Completion/Basic |\n| 智能补全 | ^+⇧+Space | 是否有必要记得两个快捷键？可以统一设成一个 | Code/Completion/SmartType |\n| 语句补全 | ⇧+⌘+Enter | 直接补全当前语句，在括号特别多时非常有用 | Complete Current Statement |\n|||||\n| 从上方开始一行 | ⌥+⌘+Enter | | Start New Line Before Current |\n| 从下方开始一行 | ⇧+Enter | | Start New Line |\n| 上移/下移一行 | ⇧+⌥+↑/↓ | 上下移一行。一般用于以单行出现的元素，否则会破坏元素间的关系 | Move Line Up/Down |\n| 上移/下移一个块 | ⇧+⌘+↑/↓ | | Move Statement Up/Down |\n| 选中一个代码块 | ⌥+↑ | 常用 | Extend Selection |\n| 取消代码块选中 | ⌥+↓ | | Shrink Selection |\n|||||\n| 重复当前行 | ⌘+D | | Duplicate Current Line or Block |\n| 复制并且不删除当前行 | ⌘+C | | Edit/Copy |\n| 剪切当前行并复制到粘贴板 | ⌘+X | | Edit/Cut |\n| 关闭当前标签 | ⌘+W | 跟通常编辑器快捷键一致 | Edit Tabs/Close |\n| 注释当前行 | ⌘+/ | 随手一注释 | Comment with Line Comment |\n|||||\n| 优化import | ^+⌥+O | 没啥用 | Optimize Imports |\n| 格式化代码 | ⌥+⌘+L | 没啥用 | Reformat Code |\n\n### 语言要素生成（Language Elements/Features）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---      |:---:        |:---:          |:---     |\n| 测试、方法生成 | ^+Enter/ ⌘+N | 非常常用于创建测试方法、构造方法、覆写接口方法、覆写基类方法 | Code/Generate |\n| 创建类、文件、目录 | ⌘+N | 常用 | Code/Generate |\n| 创建override方法 | ^+O | 有用 | Override Methods |\n| 创建接口方法实现 | ^+I | 有用 | Implement Methods |\n\n### 导航（Navigation）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 转到方法/字段的声明 | ⌘+B | 调试跟代码都很常用 | Navigation/Declaration |\n| 转到方法/字段的实现点 | ⌥+⌘+B | 同上，常用 | Navigation/Implementation(s) |\n| 转到方法/字段类型的类定义处 | ⇧+⌘+B/ ⇧+^+B | 常由下两个快捷键取代 | Navigation/Type Declaration |\n| 当前类与单元测试间跳转 | ⇧+⌘+T | 非常方便 | Navigate/Test |\n|||||\n| 跳转到当前类的基类 | ⌘+U | 配套食用，效果更佳 | Super Method |\n| 类继承体系 | ^+H | | Type Hierarchy |\n| 方法继承层次 | ⇧+⌘+H | | Method Hierarchy |\n| 当前方法调用链 | ^+⌥+H || Call Hierarchy |\n| 本类及所有基类方法列表 | ⌘+F12 || File Structure |\n|||||\n| 类/方法/字段定义的快速预览 | ⌥+Space/ ⌘+Y | 小览实现，一般可以看到方法/字段参数、返回值、前几行实现，快速的信息足够了 | Quick Definition |\n| 方法文档快速预览 | ^+J | 看文档，我不常用 | Quick Documentation |\n| 方法参数快速预览 | ⌘+P | 常用 | Parameter Info |\n|||||\n| 前一个标签 | ⇧+⌘+[ | 导航常用，不过是否能以其他方式取代，比如声明式使用类查找⌘+O等。仍在探索 | Select Previous Tab |\n| 后一个标签 | ⇧+⌘+] | | Select Next Tab |\n| 往上一级 | ⌥+⌘+←/ ⌘+[ | 调代码，跟方法体系时，非常有用，下同 | Navigate/Back |\n| 往下一级 | ⌥+⌘+→/ ⌘+] | | Navigate/Forward |\n|||||\u0010\n| 转到下一个错误或警告 | F2 | 代码见红时，常用此快捷键快速定位，并配合万能快捷键⌥+Enter快速修复 | Next Highlighted Error |\n| 提示错误信息 | ⌘+F1 | 不常用 | Error Description |\n| 意图预测与智能帮助 | ⌥+Enter | 简单重构、移除死代码、结构调整、自动导包等| Show intention actions |\n|||||\n| project视图 | ⌘+1 | 有时导航项目结构时常用，不知是否有替代方案 | Other/Project |\n| search/find视图 | ⌘+3 | 除了这几个，其他视图都不常用 | Other/Find |\n| run视图 | ⌘+4 | 有时开关测试视图 | Other/Run |\n| debug视图 | ⌘+5 | | Other/Debug |\n| VCS视图 | ⌘+9 | | Other/VCS |\n| terminal视图 | * ⌘+0 | 自己改过，一是和各种视图快捷键保持一致，另外是原生的⌘+F12实在有点难按 | Other/Terminal |\n| 隐藏所有工具视图 | ⇧+⌘+F12 | 同时开了工程和终端视图时一键回编程页面 | Hide All Tool Windows |\n|||||\n| 跳转到第...行 | ⌘+L | 属于细节型的活，能少用就多思考替代方案 | Navigate/Line... |\n\n\n### 重构（Refactor）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 复制类/目录等 | F5 | | Refactor/Copy |\n| 移动类/目录等 | F6 | | Refactor/Move |\n| 元素(类/方法/变量/…)重命名 | ⇧+F6 | 最常用的重构快捷键之一了吧 | Refactor/Rename |\n| 类/方法签名修改 | ⌘+F6 | | Refactor/Change Signature |\n|||||\n| 字段(类级别)抽取 | ⌥+⌘+F | | Extract/Field |\n| 常量(类级别)抽取 | ⌥+⌘+C | | Extract/Constant |\n| 变量(方法级别)抽取 | ⌥+⌘+V | | Extract/Variable |\n| 参数(方法级别)抽取 | ⌥+⌘+P | | Extract/Parameter |\n| 方法抽取 | ⌥+⌘+M | 最常用的重构快捷键之一 | Extract/Method |\n| 方法内联 | ⌥+⌘+N | | Refactor/Inline |\n\n\n### 搜索（Searching)\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 搜索 | ⌘+F | 通常快捷键 | Find/Find |\n| 替换 | ⌘+R | 正则发挥作用的地方 | Find/Replace |\n| 查找引用点 | ⌥+F7 | 重构或调试的时候经常用到，使用频率高 | Find/Find usages |\n|||||\n| 查找类 | ⌘+O | 声明式编程，使用频率很高的快捷键 | Navigate/Class |\n| 查找文件 | ⇧+⌘+O | 同上，使用频率很高 | Navigate/File |\n| 查找symbol | ⌥+⌘+O | 基本不用，不知道与上两者有什么区别 | Navigate/Symbol |\n| 全项目文本搜索 | ⇧+⌘+F | 搜索引用点和文本出现、改bug时非常有用 | Find/Find in path |\n|||||\n| 查找下一个 | ⌘+G | | Find/Find Next |\n| 查找上一个 | ⇧+⌘+G | | Find/Find Previous |\n\n### 运行时（Runtime）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 编译 | ⌘+F9 | 调bug时可能是忘了编译最新代码 | Make Project |\n| 运行(最近一个测试) | ^+R | 非常有用，有时可能节省在测试代码和源文件之间的切换 | Run/Run |\n| 调试 | ^+D | | Run/Debug |\n|||||\n| 打断点/取消断点 | ⌘+F8 | | Toggle Breakpoints |\n| 查看所有断点 | ⇧+⌘+F8 | | View Breakpoints |\n| 跳入 | F7 | | Run/Step Into |\n| 跳出 | ⇧+F8 | | Run/Step Out |\n| 智能跳入(当前行多个调用时) | ⇧+F7 |\n| 跳过(下一步) | F8 | | Run/Step Over |\n| 求表达式值 | ⌥+F8 | | Evaluate Expression |\n| 停止调试 | ⌘+F2 | | Run/Stop |\n"},{"id":"2016-08-07-tieba-final-summer-competition-review","title":"2016年五子棋贴吧★拯救玛利亚杯★ 备战录与棋评","contents":"\n\n报名比赛后有两周的时间，说起来因为每天要上班，因此实际的准备时间加进来其实不长，而且谱看多了有时还会恶心干呕。然后前段时间听了九指老师的高级班，对，我是顺便来安利一下九指的高级班的！听了高级班，讲到布局准备的一些东西，这次比赛里也有意识地去分析对手和准备开局。虽然针对个人的准备，最后都用在了别的人身上。\n\n总结起来，本次比赛发现自己还有很多不足，比如对于大型局面控制能力较弱、用时仍有不妥当的地方，中盘战斗力还要提高。好的地方是，尽力地准备了开局的变化，以及风格上还是在朝我喜欢的精准和暴力的方向发展。\n\n## 自我分析与可开局面分析\n\n一直以来，定式是我较弱的一块，尤其是复杂局面。计算力方面大概平均10步，在综合实力中应该不会成为短板。风格方面，我有意识地朝激烈、极限的方向去培养，喜欢进攻的快感。那么布局上如何通过准备，平稳地度过开局进入中盘，便是这次比赛准备的主要目标。\n\n局面方面，我也把26个开局在二打下结论和主观操作难度过了一遍，大致把它们分为三类：必胜并且不能主动开的局面、可战局面、超复杂局面。比如说：\n\n* 下意识排除的开局：寒星、恒星、花月、浦月\n* **必胜且不能主动开的局面**：主要是过于简单的一二打，或者通过简单套外势就能杀的局面，比如金星一打、水月两打、云雨月一打（二打还是有可考点）、明星一打、溪峡月两打等；\n* **可战局面**：黑白小优/中优局面，或即便理论必胜，但主观上仍然比较复杂的局面，比如银月二三打、明星二三打、残月、山新、名岚、流星等；\n* **复杂局面**：疏星、瑞星、松月、斜月。这些局面我觉得我还控制不太好。\n\n总结起来，开局的策略是这样：\n\n* 如果是实战经验丰富、综合实力明显比我强很多的选手，那么开疏星瑞星等大型局面我几乎必死，也即是说，被开局时不能开直指，开斜指，进入斜月或明星等局面；如果是我开局，斜指则用斜月，直指的话使用金星或疏星\n* 如果水平相当棋手，被开局随机应变，稳妥即可；我开局时则直指可下松月、疏星、金星等局面，斜指则云月二打、明星、斜月、银月等战斗局面都可以考虑\n\n下面上棋评。\n\n## 第一局\n\n> （人机6）普通的士兵：零度以下\n\n普通士兵自知不敌，一掌拍向了自己罩门，经脉尽断而忙。零度以下0手胜。\n\n## 第二局\n\n> 对局双方：零度以下【黑】：ran小小爱o【白】，不交换，5A-34，黑胜  \n> 用时：零度以下 读秒0:58 ：ran小小爱o 03:25\n\n![](http://oa6tlgkic.bkt.clouddn.com/2.jpg)\n\n可以看到我开斜指的缘由。但事后觉得还是开一三打较好，这个定式执黑我没有变招的余地，感觉13、15的变招都容易死，没有勇气考。于是定式一口气摆到27，微妙之处是H12（39）这个点忘了盖。这个局面是我第一次下，因此其中各部要点我也不是很清楚。\n\n33、35的交换思路是利用上方的优势，借一些棋到下方来，各处攻击。因此如果36-37，37-36，黑棋上下联系依然存在。然而38防守时，忘记上方39要点，被黑棋抢占后即已无法防守。\n\n## 第三局\n\n> 对局双方：乱码经理【黑】：零度以下【白】，不交换，5A-7，白胜  \n> 用时：乱码经理 03:54 ：零度以下 读秒 01:00\n\n![](http://oa6tlgkic.bkt.clouddn.com/3.jpg)\n\n刚坐下乱码就说度爹好，我就猜一定是群里攻攻受受中的某只了～原来是热爱妹子啊。不得不说，小号真是多。热爱开局，流星，一看这开局我就想得，戳中我毫无准备的局面了，那就只能遵循赛前以稳为主的作战方针，慢慢下了。想到这，我想那就留那个挡活二的5吧，于是我就点了一下，然后这5就被拿走了…\n\n短暂的戏虐啊不戏谑过后，其实觉得还好，6活三交换的定式我还是知道一些。定式正常进行到白10，黑11变招。脱谱第一手，马上长考（请听高级班）。不过这是比赛的第二局，说实话我脑袋还有点懵，不知道思考些啥，大致构思的是12、14的手段，黑棋眠三必挡，否则变化太多，迟早是后患。本来构思是若13反挡，14也走实战14，但这样14恰好是败，请见下面第一图拆解。\n\n长考5~6分钟后，实战12、14预想的手段，14的活二往上往下都有制作禁手进行进攻的手段，全局白棋比较生动，还是挺满意的。此时我主要考虑的是15-22这样挡外围的手段，不过热爱落下15的速度还是挺快的，我一看这是要包饺子啊！下12、14时没有考虑这样的15，于是临场算。实战时看到16、18的手段，已算到19的唯一防，觉得很有前途，于是花了剩余时间验证了16、18手段。落下时已读秒。不过20活三之后后面的进攻就比较清楚了，每分钟1步已经足够。白胜。\n\n![](http://oa6tlgkic.bkt.clouddn.com/3-2.jpg) ![](http://oa6tlgkic.bkt.clouddn.com/3-1.jpg) ![](http://oa6tlgkic.bkt.clouddn.com/3-3.jpg)\n\n第二图是实战13反挡时正确杀法，白棋强撸即胜；第三图是实战15挡外围时的杀法。\n\n## 第四局\n\n> 对局双方：落霞齐飞孤鹜【黑】：零度以下【白】，零度开局，小土豆交换执黑，5A-6，白超时负  \n> 用时：落霞齐飞孤鹜 读秒01:00 ：零度以下 读秒 0:00超时\n\n哎呀，这局棋学到很多东西，对一个先手所能进行的进攻和控制有了更深的体会。同时，对于准备好的变化，真的还要在实战前拿去练练，看看实战起来这个局面究竟能不能走，一般棋手会怎么思考，要点在哪里，等等。\n\n我认识小土豆，他不认识我。根据贴吧发的一些棋来看，感觉谱量比较大，战斗经验也很多，擅长快棋，计算力不知道，但棋感应该很好。不过由于小土豆报名较晚，我没有对他进行准备。我还是认为拼瑞星疏星肯定是死了，既然大型局面拼不得，那就把之前准备的一个金星大招拿出来用用呗。然后刚好是我开局，小土豆给直指，布局就顺利进行了。\n\n![](http://oa6tlgkic.bkt.clouddn.com/4.jpg)\n\n实战走到10手之后，就是我在金星二打中搜刮出来的一套不是能很简单套外势杀的必胜。黑棋长考，在11手的选择上用了10+分钟，对于只有15分钟的比赛，真是感觉有魄力。11手正确应对，12继续预定的考，之所以选择这个局面，是因为黑棋虽然必胜，但经过事先拆解，右边局部黑棋的必胜点是唯一的，其他看似强劲的进攻要么速败，要么导致局面不能必胜。本来以为只剩几分钟13肯定走不出正解的了，不过实战的13我没有考虑过。此时小土豆即将进入读秒了，不过我并没有松懈，因为13刚好脱了我的谱，况且土豆快棋也很强，说明真正的战斗现在才开始。\n\n14的选择上我并没有进行太长思考，15、16也如预料，一是因为这个16我也拆过，右上无杀，并且既然对手已经读秒，此时战术应是快速应对，给予对手时间压力，同时一边寻找黑棋破绽。\n\n然而17落下我就擦了一声，很显然我之前并没有考虑到17这样控制的手段。冷静了一下，快速分析了一下局面。白没有必败，因为黑是走脱了必胜的，但毕竟是黑优局，黑看起来是联系全局进行控制的节奏，白必须小心防。一下就感觉前期的优势不存在了好么，然后18开始就是白棋的防守，黑棋也是本着全局联系的思路，凭选点的感觉做棋。白防守时既不能让黑直接出vct，也不能让黑太简单飘到其他局部，基本我下完防守就知道黑棋要往哪儿飘了，真是心碎…19虽然符合常理，但在我思维之外，做棋好手。\n\n38寻求激烈的手段复杂化局面，41后黑棋下方已是白棋一手棋即可防住。白要在上方争取主动侵占空间后，先手回防下面，再寻找机会。一切都是那么刺激，然而此时我超时了。\n\n![](http://oa6tlgkic.bkt.clouddn.com/nick-young-mengbi.png)\n\n金星二打准备的这个考是这样的，如下图。13是局部唯一能必胜的进攻，其他A~D的进攻看似强劲，其实都必败；15活三也是几乎唯一的进攻。\n\n![](http://oa6tlgkic.bkt.clouddn.com/4-1.jpg)\n\n细细想来，白棋防守还可斟酌，因为本局基本是被黑棋轻松控制的节奏。另外，要对考的局面有更深的理解，因为既然是考黑优局，就要面对黑棋各种各样的进攻手段，它们虽然客观上不必胜，但主观上若理解不深，很可能就是自己中招了。\n\n不过，最大的问题似乎还是考黑优局这件事本身。之前因为定式接触少，一直对一些传闻中黑优/黑好控制的局面没有认识，认为可战，但经此一战，对黑棋一个先手的力量算是有了感觉。如果实战黑棋非常容易控制，或者有非常强烈的骗，那么将非常考验白棋的耐心与实力。因此，黑平衡局的学习似乎对我而言变得重要。总结起来，开局算是成功，中盘细节处理有待提高。\n\n## 第五局\n\n> 对局双方：零度以下【黑】：残花灬赤瞳【白】，不交换，5A-3下，白胜  \n> 用时：零度以下 00:37 ：残花灬赤瞳 02:17\n\n和小土豆的一局后，我觉得我还是得准备下平衡局，于是回来还是做了一些疏星的功课的，几个打点的前面10步不求甚解地看了遍。残花上一局的疏星也是用了这个6，我依然给这个5的打点，一是因为我做了一些准备，并认为残花有可能会选择自己熟悉的这个5进行战斗；二是根据我的准备，我认为是黑好走，并且没料到对手这么强。说白了，可能还是有点轻敌，不然还是不应该轻率地又给这个5。\n\n![](http://oa6tlgkic.bkt.clouddn.com/5.jpg)\n\n实战至15，完全在我的掌握之中，赛前主要准备的就是这个定式。棋情谱上就到这个15，此时我认为我的开局策略是成功的，度过了定式阶段，黑开始做棋。我还以为是黑优了呢，没想到是这样的结局！\n\n16，黑有左挡和实战两种手段。左挡在我看到下图的路线后，否定了，认为17后18跳三，然后就没有然后了。但实战20非常积极且强烈的手段！这个棋确实在我考虑之外，然而此时还没有死，另一个错就是此时的21我应该长考。而实战简单排除了一些线路（而非细算）之后就选定了21的防守。心浮气躁了。后面白理论必胜无误，实战自然但漂亮的追杀。\n\n第一次拼疏星就惨挂。这局棋，出现了我意料之外的20这样的手段，白优势局面下没有处理好，我服，学到了东西。不过，21自己没有长考选择好防守，也是心态还不够踏实的表现。同时，平衡局看来真是需要深入学习，并非背背谱就可以。也许其他事情也是这样的，一个事情要做到极致，必然需要积累和沉淀。精神应该在学习本身，体会当下学习的乐趣，而非执着于学到了多少、是否已经变强了这样的“结果”，心应该更沉静。这是需要时刻提醒自己的。\n\n![](http://oa6tlgkic.bkt.clouddn.com/5-1.jpg)\n\n如上图，17防活二外侧，18以下的进攻其实并不成立，25-A即可。\n\n## 第六局\n\n> 对局双方：聆视仙诉【黑】：零度以下【白】，不交换，5A-6左，白胜  \n> 用时：聆视仙诉 08:31 ：零度以下 读秒01:00\n\n![](http://oa6tlgkic.bkt.clouddn.com/6.jpg)\n\n看了一下仙诉前几轮的对局，感觉云月准备的有一路变化可以使用。不过黑7直接脱了我谱，而且和他对阵上一轮对手的7是同一个。白棋小心应对，毕竟是黑优局。28、30的进攻我觊觎已久，不过有几个防守找不出局部杀，所以22~26一直在上面积攒些材料。32果断转身，也是没办法中的办法，因为此时我又快读秒了，上面的杀法尽管没有地毯，但也只好一试。37直接防守就被简单抓三三了。\n\n本次云月准备的局面是下面两个。左图考点一是在15，二是在21，这一路是黑棋必须非常精细敢走才能杀出，本来是想着对于喜欢套外围而疏计算的棋手能用上；右图则是存在21这样的后中先妙手。\n\n![](http://oa6tlgkic.bkt.clouddn.com/6-1.jpg) ![](http://oa6tlgkic.bkt.clouddn.com/6-2.jpg)\n\n## 第七局\n\n> 对局双方：欲语泪流kun【黑】：零度以下【白】，不交换，5A-2右，白掉线日了汪怨念脸，和棋\n\n![](http://oa6tlgkic.bkt.clouddn.com/7.jpg)\n\n12开始已经有vct，我是有想过，还算不清。14局后拆解，接近必胜，进攻还是挺爽的，然而爽到一半突然断线。就不说啥了。对家最后还是说和棋，没有直接算负，还是很感谢。\n\n棋评结束，没有总结。谢谢阅读 :)\n"},{"id":"2016-08-25-tdd-series-1-techniques","title":"TDD的迷思（一）：技艺篇","contents":"\n\n> 本章简要讨论使用TDD对软件开发所能带来的益处，给出了TDD作为一门技艺的修习技巧和手法。如还有篇幅~~心情和精力~~，会再讨论各处可能遇到的疑惑和解决方案。关于为什么要使用TDD、TDD的使用场景，请见本系列第二篇：意义篇；关于TDD的一些其他声音，请见本系列第三篇：撕逼篇。\n> \n> 本篇讨论TDD使用Java作为编程语言。\n\n## 从红绿循环说起\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/tdd.png)\n\n说起TDD，这个经典的红绿循环想必不陌生。简单来说，就是先根据需求，写一个会挂的测试，然后再写最小的实现代码实现它。必要的时候重构，不断重复这个过程直至需求完成、代码整洁。看似很简单，其中细节却很多。比如，从一个最基本的问题思考起：“需求”这么高层的概念，最终如何落实为一个具体的单元测试？这种对应关系从何而来？\n\n### tasking\n\n答案很简单，有鸿沟，就消除之。无非是通过大而化小、分而治之的方法：先将需求划分为多个较小的“功能/特性”（feature），再对这些粒度稍小的特性制定验收标准：一组或多组测试。这一（多）组测试都必须具有明确的输入和输出，有了输入和输出，对应下来恰好就是一个具体的测试用例。这个分而治之的过程，在TDD中就叫tasking。\n\ntasking是将需求转化为可量化的单元测试的一种思维方式与方法论。在实际操作中，可能还有许多细节上的问题。以我的经验，逻辑顺序从上到下分别为：\n\n1. 按照什么标准/依据来划分feature？\n2. feature之间是否可能有依赖？若有，是否能有克服办法？若无，是否有方法论做到如此完美？\n3. feature之间有无技术上的优先级？\n4. 测试驱动与提前设计之间的关系。以不走极端的方式来讲，测试与设计都是需要的。那么设计什么时候进行？设计在TDD中所占比重，是否与开发者个人经验、信心，甚至需求类型均有关？\n\n这些问题虽是细节，但细节处见功力。本小节先只回答如何将需求对应到一个个单元测试——即通过tasking——这个问题，至于操作细节如何处理，会在后面的小节讲解。下面我们要讲下一个问题：红绿循环。\n\n### red-green-refactor\n\n有了需求，有了单元测试，我们就可以进行红绿循环了。这个阶段又有两个细节上的问题，但回答却是开放的：\n\n* 红-绿循环的步子？有时一两个单元测试，其实现差别可能就是一个`if-else`。我很有信心代码一定正确，此时我的TDD步子可以迈大一些么？\n* 重构的时机是什么？我们说“必要的时候重构”，那么什么是必要的时候？\n\n## 寻幽探微——TDD的深处\n\n### feature的划分标准\n\n尚未探索。说是要“正交”，至于怎么个正交法，我还需要研究。目前，我只能先回答，按照做事的逻辑顺序，凭直觉划分。\n\n### feature间的依赖\n\n假设我们已经tasking出来几个任务，那么任务之间的开发次序呢？假设任务A依赖于任务B，那么我们如何识别出这种依赖，并保证我们先实现任务A呢？答案是，**我们不需要提前识别依赖关系，单元测试只测试一个单元，与该单元无关的依赖可以mock掉**。\n\n#### 举个简单的栗子：ThoughtWorks POS Machine练习\n\nThoughtWorks有一个[POS机练习](https://github.com/trotyl/pos-machine)，要求读入一些商品的信息，最后打印出一个小票。针对这个需求，我做的[tasking](https://github.com/linesh-simplicity/TDD-series-pos-machine/blob/master/TODOLIST.md)是这样的：\n\n```markdown\n* [ ] 读入商品信息(json -> [other format])\n* [ ] 读入打折清单(json)\n* [ ] 读入客户购买商品信息\n* [ ] 进行优惠计算\n   * [ ] 计算总价\n   * [ ] 计算优惠\n* [ ] 打印小票\n```\n\n这里有一个细节：**它按照一个逻辑上的顺序来task，而非按照具体的实现**（比如在MVC的架构下，把需求依照三层架构依样分出三个task等，不要怕跨层，不要怕全栈），这可以确保我们在task的时候尽量保持在同一个抽象层级，而不会陷入具体的实现细节。\n\n> 扎爷：当然，熟悉了TDD的节奏以后，你可以游走在测试与实现之间没有挂碍，测试时想到实现细节，实现时想到测试。但这是进阶水平。\n\n这里我认为业务价值最高的部分是能优惠与总价计算部分，因此我打算最先实现这个模块。不过问题来了，这个时候必要的依赖都还没有实现：商品对象尚未出现，拿不到总价；优惠列表尚未读入，拿不到商品应享优惠。这是不是意味着我们要放弃当前任务，先去实现读取优惠的模块？回答否定。优惠和总价计算模块，最核心的功能就是计算总价/优惠，商品对象怎么来，是否享用优惠，不是这个模块所关心的内容，可以mock掉。最后写出来的代码会是这样，只测我们这个模块的功能：\n\n```java\n\t@Test\n\tpublic void should_return_60_cents_when_two_3_dollar_apple_offered_90_percent_discount() {\n\t\tGoods apple = new Goods(\"apple\", 3.00);\n\t\tgiven(promotionManager.isProductOfferedPercentageDiscount(apple)).willReturn(true);\n\t\t\n\t\tdouble discount = calculator.calculateDiscount(2, apple);\n\t\t\n\t\tassertThat(discount, is(0.60));\n\t}\n```\n\n把握好这种节奏感：只测模块相关的内容，把外部的依赖mock掉。这很有利于我们聚焦于当前模块，进而有次序有节奏地完成系统的其他部分，而不会在TDD的过程迷失方向，不会出现诸如在controller测试中连接了真实的数据库、在service测试中同样调真实的数据库，或者在controller中真实地去调mapper等现象。\n\n#### 真实的例子：一个典型Spring Boot + Spring MVC架构的REST风格的API调用\n\n> 把最近项目上的需求包装一下，形成下面的例子。\n\n假设你现在正在JetBrains下的Intellij IDEA团队工作，团队即将发布一个大版本的更新：2016.12.32.future，现在你们需要做一个quick start guide，数据可以全部由后端提供，前端只是负责简单的渲染。于是，现在后端需要向前端提供一个类似 `/idea/{version}/{category}` 格式的API，前端将用其渲染目录树。这个API的实现大概构思如下：\n\n```java\n@RestController\n@RequestMapping(\"/idea\")\npublic class DocumentationController {\n\t@Autowired private DocumentationService documentationService;\n\t@Autowired private ResponseMapper mapper;\n\t\n\t@RequestMapping(value = \"{version}/{category}\", method = GET)\n\tpublic Category getCategory(@PathVariable String version, @PathVariable category) {\n\t\t// 1. retrieve all topics under specific category of a specific version intellij from documentationService;\n\t\t// 2. map the retrieved json response to domain object;\n\t\t// 3. return the mapped object\n\t}\n}\n```\n\n很显然，这个API要做的事就是：使用service从数据库中取回数据、使用mapper将取得的数据进行适当处理映射、返回映射后的对象，Spring会负责将我们的对象转换成json，这个不需我们操心。这里几乎涉及了一个正常的后端请求处理流程会过的所有层：控制器层、服务层、数据库层，还有一些mapping的工作，那么具体到我们这个controller，我们如何对它进行TDD呢？难道所有的层级我都要真实调用并确认结果才能保证安全感吗？难道所有的依赖我都得先去实现吗？很显然，这样我们就做成了集成测试，既会混淆我们真正的测试目标（控制器的逻辑），又会使得耗时比一般的单元测试高出10倍甚至百倍，影响开发体验。那么我们所说的测试目标——controller——它的功能是什么呢？稍加整理，不难发现，其实就是注释中提到的三个事情：\n\n1. 确保使用正确的参数（version和category）调用了documentationService，并取得返回数据\n2. 确保使用service返回的数据作为参数，调用了mapper对其进行转换，并得到一个对象\n3. 确保返回了mapper转换得到的对象\n\n很多时候这个地方我们容易迷惑的点，在于真的去调service，service又真的去连接数据库，真的去做mapping。但在控制器层，service是如何取得数据的、mapper又是如何处理返回数据的，其实现controller不需关心，controller自身的逻辑，其实只是组合手上的service和mapper，确保它们以特定的参数与次序被正确调用，并如实返回结果而已。有同学可能会有疑惑：关键功能都mock了~~我还测个毛啊~~这样的测试还有什么意义？没错，似乎service和mapper部分功能是真正涉及数据的，是核心功能，但我也没有说不去测service和mapper啊，相反，在service层和mapper我会采取相应的测试策略去对它们进行覆盖；那么，controller这层的测试有什么意义，读者不妨思考，下面这个测试中的一些断言如果去掉，其测试的内容变成了什么，是否可能有遗漏的点，加不加断言有什么区别：\n\n```java\n@Test\npublic void should_call_service_and_use_mapper_to_process_fetched_data_when_category_api_is_called() throws ...{\n\tgiven(documentationService.getCategory(\"4.2.4\", \"startguide\")).willReturn(mockCategory);\n\tgiven(mapper.mapCategory(mockCategory)).willReturn(new Category().withName(\"startguide\").topics(\"installation\", \"user-interface\", \"completion\", \"shortcuts\");\n\n\tCategory category = controller.getCategory(\"4.2.4\", \"startguide\");\n\t\n\tverify(documentationService, times(1)).getCategory(\"4.2.4\", \"startguide\");\n\tverify(mapper, times(1)).mapCategory(mockCategory);\n\tassertThat(category.getName(), is(\"startguide\"));\n\tassertThat(category.getTopics(), is(/* installation, user-interface, completion, shortcuts */));\n}\n```\n\n恭喜你，现在你成功地拿到了来自Intellij后端的返回，祝发布会一切顺利！！\n\n```\n/idea/4.2.4/startguide\n{\n\t\"version\": \"4.2.4\", \n\t\"category\": \"startguide\",\n\t\"topics\": [\n\t\t\"installation\", \"user-interface\", \"completion\", \"shortcuts\"\n\t]\n}\n```\n\n### feature的优先级\n\n有了前节讲解的mock技术，使用得当，我们可以从技术上解决几乎大部分依赖的问题。因此，我先实现哪个feature都是技术可行的。个人偏好，是优先实现从业务角度讲价值最大的feature。这个问题似乎比较开放，见仁见智。\n\n### 测试驱动与提前设计\n\n又是一个大的话题。也许我可以先邀请 @林波 @滕老板 来回答一下~>_<~我决定等我看过Kent Beck的《测试驱动开发》和滕老板译的《领域驱动设计》再来补这个坑。\n\n### 红绿循环的步子——一个个写太慢了！\n\n上面提出的迷惑是，我~~没有蛋，不怕扯着~~TDD的步子能迈大点儿不？我的回答是，当然可以。但前提是什么，是你对TDD这门技艺、节奏乃至于你要实现的代码都已经有了一定程度的掌握（foresee），你清楚自己处于什么阶段，清楚自己测了什么，没测什么，目标是什么。\n\n### 重构的信号\n\n这是一个好问题。我有一个自己的重构列表，尚在补充之中。目前简单说来，就两点：\n\n* __硬编码常量__\n* __重复代码__\n* 其他《重构》一书中提到的味道\n\n首先要弄清楚一个问题，重复代码中的重复意味着什么呢？存在重复的逻辑。因为这些代码在处理一些相同的事情。为什么要在编写下一个测试之前重构它？因为，测试代码与产品代码之间存在依赖关系，不可能改动其中一处时能够不改动另外一处。那么在编写下一个测试用例之前重构成功能尽可能单一的代码，就可能使下次测试用例所需要修改的代码量最少。这个道理，在业务加需求你回过来修改自己的代码时，感受最明显。\n\n这个味道在你最小实现的时候必然会出现，那么必须保证你这坨代码工作完以后一定是干净的。同时，实践中在遗留代码上工作就不是这样的玩法了，此时我们可能需要先加测试再重构，当然这是后话，见后文与下篇。\n\n硬编码常量如何消除呢？转换为变量。那么这个变量放在什么地方呢？无非三个地方，按出现频率与推荐程度从高到低依次为：\n\n* 方法传入参数（parameter）\n* 类字段/属性（field）\n* 方法内变量（variable）\n\n## 迷思——FAQ\n\n### 概率与信心\n\n啥？工程论里居然有概率？怎么听起来非常不靠谱？\n\n### 遗留代码的TDD与重构\n\n对于一个大型遗留项目的TDD与重构，请见本系列第二篇。\n"},{"id":"2016-08-26-tdd-series-2-why-and-when-using-tdd","title":"TDD的迷思（二）：意义篇","contents":"\n\n> 本文仅在Java上下文下讨论TDD。原因是Java具备适合TDD生存的一些语言特性：清晰的依赖引用import机制、完全的面向对象、不存在引用传递等。迁移讨论至其他语言上时请注意这些特性对TDD实践所带来的差异。\n\n## 背景：银弹还是鸡肋\n\nTDD还是不TDD，这是在ThoughtWorks工作绕不过去的一个问题~~怎么总觉得[这帽子扣得没熊节好](http://www.infoq.com/cn/articles/enterprise-systems-integration-points)[^summarize]~~。TDD是一种思维方式，它把测试带到了与开发同等的地位上来。如果想要让你的代码边界清晰，有序可控，自成模块文档，那么你必须写清晰易懂的测试，你必须知道单元测试如何覆盖产品代码。若果如其然，是不是每个ThoughtWorker都认同TDD，并自觉在项目上使用TDD？若并非每个人都做到，原因又是什么，是因为TDD确实也有它不适合的场景，或一言以蔽之，是因为人员TDD技巧与素养皆太菜？\n\n第一个问题的答案是否定的。是不是每个ThoughtWorker都认同TDD这个我不清楚，因为我是认同的，而其他人我则懒于主动求证是否认同，故此命题无法证假；但后半句答案是否定的，至少我就不是，我自觉，但并非所有时刻都用；昨天和我聊TDD的澳洲ThoughtWorker阿蒙萌也是看情况用。我们2票便否定了“每个”这全称量词。那么，既然至少有2人在项目没有坚持使用TDD，（他们的）原因又是什么？阿蒙萌曰：\n\n> It depends. \n\n言下之意，TDD有时好用，有时难用。且就这个论断继续讨论下去，那么TDD什么场景下好用，什么场景下难用呢？那些难用的场景，是人员主观上技巧素养太弱而产生的误解呢，还是客观上真实存在的障碍呢？\n\n### TDD适用场景\n\n* 输入输出非常清晰时（clear input/output）\n* 项目代码采用良好的MV*(MVP/MVC/MVVM)架构时（well MVP/MVC/MVVM designed）\n\n### TDD不适用场景\n\n* 使用全局变量在方法间传递、保存值（shared global variable across methods in class）\n* 有副作用的方法（side-effect methods）\n* 无返回值的方法（void methods）\n* 逻辑层和视图层间耦合严重（logic deeply coupled with the view）\n\n### 函数式的代码风格\n\n适用第一点与不适用的第一二点其实是一个意思，即接近于[函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)的代码风格：**清晰的输入输出**、**无副作用**、**引用透明（Referential Transparency）**。毕竟，没有输入输出，就没有测试用例。遵循测试驱动开发写出来的代码可能是这样的：\n\n```java\n@Test \npublic void should_give_80_percent_discount_when_customer_buying_over_3_apples() throws Exception {\n\tdouble amount = customer.buy(4, apples.withEach$(5.00));\n\t\n\tassertThat(amount, is(4 * 5.00 * 0.8));\n}\n```\n\n### 外部依赖\n\n不适用的第三点：没有返回值的方法。方法没有返回值，有以下几种可能的情况：\n\n* 使用了全局变量，或修改或存储了应用的状态以供他用。这其实就是违反“函数式代码风格”的理念，见上讨论\n* 使用了输出参数。通常是在传入参数是个类型引用，然后在方法体内往传入参数中写值，从而达到方法返回值的效果\n* 调用了三方服务。比如进行了数据库操作、网络连接、文件读写等一切形式的I/O（非内存）操作\n\n首先我想表达的观点是，按照TDD进行的设计，很少会出现这种自己也测试不了的代码。但既然软件工程是人的行为，坏代码总会出现，那么以上面两点可能为例，这是无法解决的客观因素，还是可以解决的呢？可以解决。如果方法中使用了输出参数，那么可考虑是否将代码重构成正常的返回值方法；如果方法中调用了三方服务，那么测试策略可以从 **验证返回值** 的思路转换为 **验证特定行为确实正确发生**，这与第一篇技巧篇中提到的依赖注入技术和mock对象即可实现。\n\n但不可否认，上面的“重构”这个字眼，意味着我们在TDD时，可能会有额外的投入，如额外添加测试保障、重构旧有代码等。这个问题，已不能从单纯技术层面进行解决，但后面我会聊。\n\n### MV*架构——核心业务逻辑与模型/视图的解耦\n\n适用和不适用场景的最后一条，都提到了MV*架构对于TDD有所裨益。原因何在？因为有了清晰的分层，大部分主要的业务逻辑将由C（Controller，控制器）或VM（View Model）来负责。通过将领域模型和展示视图隔离出去，我们得以厘清业务层的输入输出。这回到了我们所聊到的第一点情况：函数式风格的输入输出。\n\n不难发现，那些我们提到“TDD不一定适用”的场景，无论是因为代码上使用了难以测试的全局变量/输出参数，还是因为架构上业务逻辑与视图展示逻辑强耦合引起的测试黑洞，归根结底都指向了一个问题：取决于代码库设计/实现的好坏。好的代码容易TDD，自然维持更好；坏的代码TDD寸步难行，后来者更倾向于copy/paste重复代码，自然质量每况愈下。因此，看人品，如果你人品好，工作在优雅的codebase上，那就能TDD，否则就不能。\n\n聊到这里似乎是把开发者的责任撇得干干净净：这是代码库的责任，而与开发者自身的TDD技艺、素养等无关。但我们不能止步于此，且不论好代码是如何得来，也暂且不论什么架构腐化演进的问题~~因为我现在也聊不来…~~，这里有一个问题Developer有责任思考及行动：**重构（大型）遗留项目是否有价值？若是，如何对（大型）遗留项目进行重构？**\n\n## 大型遗留项目的重构与TDD\n\n我们从TDD一路聊到大型遗留项目的重构，似乎是跑了题。这里为何强调大型？因为小型的重构和TDD可以在短时间（2~3天内的体量）完成，它们可以作为需求的一部分同时被交付，不涉及系统级的重构。一加大型，我们就需要意识到：其所需投入的时间和人力，已大至需要作为项目范围的一部分被规划和交付。那么，首要的问题即是，这样大型的系统重构，是否有意义？其价值何在？\n\n### 重构大型遗留项目的价值\n\n要探讨价值，就要知道价值是什么，它需在一个系统和业务的上下文中展开。\n\n---\n\n[^summarize]: “集成是企业应用系统中绕不开的话题”。首句即把帽子扣下，这是绕不开的，所以我才来聊聊。真假不论，先装腔作势一番。\n"},{"id":"2016-09-17-junit5-architecture","title":"「译」JUnit 5 系列：架构体系","contents":"\n\n> 原文地址：[http://blog.codefx.org/design/architecture/junit-5-architecture/](http://blog.codefx.org/design/architecture/junit-5-architecture/)  \n> 原文日期：29, Mar, 2016  \n> 译文首发：[ Linesh 的博客：「译」JUnit 5 系列：架构体系][JUnit 5: Architecture]  \n> 我的 Github：[http://github.com/linesh-simplicity](http://github.com/linesh-simplicity)\n\n现在，我们已经知道了 [如何配置 JUnit 5 环境][JUnit 5: Setup] 及 [如何写一些测试][JUnit 5: Basics]，接下来就来看一点封面下的内容吧。本篇我们将讨论 JUnit 5 的架构体系，以及它之成形如此的原因。\n\n## 概述\n\n本文章是这个 JUnit 5 系列的一部分：\n\n* [环境搭建][JUnit 5: Setup]\n* [基础入门][JUnit 5: Basics]\n* [架构体系][JUnit 5: Architecture]\n* [扩展模型（Extension Model)][JUnit 5: Extension Model]\n* [条件断言][JUnit 5: Conditions]\n* 注入\n* [动态测试][JUnit 5: Dynamic Tests]\n* ...\n\n（如果不喜欢看文章，你可以[戳这里看我的演讲](http://blog.codefx.org/past-talks/)，或者[看一下最近的 vJUG 讲座](https://www.youtube.com/watch?v=ct9sIsrnE9Y)，或者[我在 DevoxxPL 上的 PPT](https://www.youtube.com/watch?v=oG80XZUN1lQ)。\n\n本系列文章都基于 Junit 5发布的先行版 [Milestone 2][User guide: M2]。它可能会有变化。如果有新的里程碑（milestone）版本发布，或者试用版正式发行时，我会再来更新这篇文章。\n\n这里要介绍的多数知识你都可以在 [JUnit 5 用户指南][User guide: M2] 中找到（这个链接指向的是先行版 Milestone 2，想看的最新版本文档的话请戳[这里][User guide: Current]），并且指南还有更多的内容等待你发掘。下面的所有代码都可以在 [我的 Github](https://github.com/CodeFX-org/demo-junit-5) 上找到。\n\n## 目录\n\n* JUnit 4 \n* JUnit 5\n    * 分离的关注点\n    * JUnit 5 的重新组织\n    * 架构及体系\n    * API 生命周期\n* Open test alliance\n* 回顾总结\n* 分享&关注\n\n## JUnit 4\n\n除了 Hamcrest，JUnit 4没有任何外部依赖，其所有的功能都被打包在一个构件（artifact）中。这完全违反了单一职责原则，它被提供给开发者、IDE、构建工具、其他测试框架、其他扩展等使用，不同的使用者，依赖的都是一个同样的构件。\n\n而在这其中，只有开发者能——或者说曾经能——以最干净的方法来使用它。他们通常只需要 JUnit 的公共 API，不需要管其他的。非常好。\n\n但生态圈中的其他成分则不是这样使用 JUnit：测试框架、扩展，特别是 IDE 和构建工具的开发者，他们需要深入到 JUnit 的深处，到它的细枝末节：非 public 的类、内部 API，甚至 private 字段。它们的正常工作极大地依赖于 JUnit 的实现细节。这使得 JUnit 维护团队不能轻易地修改框架的这些内部实现，因此团队的开发进度受到了很大的影响。\n\n当然，这些工具的开发者们也并非有意为之。为了实现那些我们十分喜爱的特性，他们不得不使用内部的 API，因为 JUnit 4 并没有提供相应的 API：一个强大到足以满足工具开发者们需求的 API。\n\nJunit Lambda 团队开始着手于 JUnit 5 的开发，希望能让这一切变得明朗起来。\n\n## JUnit 5\n\n### 分离的关注点\n\n退一步想，我们不难辨识出，这里至少有两个不同的关注点需要分离：\n\n1. 一个支持测试代码撰写的 API\n2. 一个识别测试、运行测试的机制\n\n再仔细思考一下第二点，我们可能会问，“哪些测试？”这个当然是指 Junit 测试。“我知道，但具体是哪些版本的测试呢？”呃…“还有，具体是指什么类型的测试？”好吧，你让我给你……“只能跑那些老版本的 `@Test` 注解的测试么？有没有其他新的方法来运行测试呢？……”行行行，都给我闭嘴！听我讲着。\n\n为了进一步将待识别测试的类型 与 实际运行它们 这两个关注点解耦，上面的第二点需要细分：\n\n1. 一个支持测试代码撰写的 API\n2. 一个识别测试、运行测试的机制\n    1. 一个识别、运行特定类型（比如，JUnit 5测试的机制）\n    2. 另一套协调上述机制的机制\n    3. 上两者之间的 API\n\n### JUnit 5 的重新的组织\n\n识别出这两个关注点以后，“作为平台的 JUnit ”（用于运行我们的测试）和“作为工具的 JUnit ”（用于撰写我们的测试）这两个概念的分离就清晰了。为了完成这个彻底的分离，JUnit 团队决定将 JUnit 5 分成三个子项目：\n\n**JUnit Jupiter**  \n包含了我们用于撰写测试的 API（关注点1），以及一个能理解测试代码的引擎（关注点2.1）。\n\n**JUnit Platform**  \n提供了一套统一的 API 以运行测试，及基于 API 之上的一套工具（关注点2.2和2.3）。\n\n**JUnit Vintage**  \n 提供了一套引擎，用以在 JUnit 5 中运行 JUnit 3 和 JUnit 4 的测试（关注点2.1）。\n\n### 架构与体系\n\nJUnit 5 的架构体系完全是遵循这个关注点分离思想的产物：\n\n**junit-jupiter-api(1)**  \n开发者用于撰写测试的 API，包含了我们在[JUnit 5 的基础知识][JUnit 5: Basics]一节中所提及的所有注解、断言等。\n\n**junit-platgorm-engine(2.3)**  \n包含了一套所有测试引擎都必须实现的 API。这样，不同的测试引擎之间可以通过统一的接口被调用。引擎可以跑正常的 JUnit 测试，但也可以实现不同的引擎用以执行其他框架写成的测试，如 [TestNG](http://testng.org/doc/index.html)、[Spock](https://github.com/spockframework/spock)、[Cucumber](https://cucumber.io/) 等。\n\n**junit-jupiter-engine(2.1)**  \n**junit-platform-engine** API 的一个实现，专门用于执行 JUnit 5 撰写的测试。\n\n**junit-vintage-engine(2.1)**  \n**junit-platform-engine** API 的一个实现，专门用于执行 JUnit 3 或 JUnit 4 撰写的测试。过去，JUnit 4 的构件 **junit-4.12** 充当了两个角色：它既是开发人员用于实现测试的 API，又包含了用以执行测试的核心组件。这个引擎，可以认为是低版本的 JUnit 3/4 与 JUnit 5 之间的一个适配器。\n\n**junit-platform-launcher(2.2)**  \n这部分使用了一个服务加载器 `ServiceLoader` 来发现测试引擎，并协调不同实现之间的执行。它提供了一个 API 给 IDE 和构建工具，使得它们能够与测试执行过程交互，比如，运行单个的测试、搜集测试结果并展示等。\n\n听起来怎样，很酷吧。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/junit-5-architecture.png)\n\n这部分架构对于我们生态链前端的使用者来说基本是透明的。我们的项目只需要引入一个用于编写测试的 API 依赖，其余的组件让工具去操心即可。\n\n### API 生命周期\n\n现在来说说那些大家都在使用的内部 API。JUnit 5 团队希望这个问题也能得到解决，为此给 JUnit 的 API 设立了生命周期。这里，我将[源码](https://github.com/junit-team/junit5/blob/master/junit-platform-commons/src/main/java/org/junit/platform/commons/meta/API.java)中给出的部分解释截取于此。\n\n**内部 API（internal）**  \n不允许被 JUnit 开发者之外的任何人使用。这部分 API 可能被移除，并且不会事先通知。\n\n**已过时（Deprecated）**  \n不应该再被使用的 API，它们可能在下次小版本发布时被移除。\n\n**实验阶段（Experimental）**  \n为一些新的、实验阶段的特性所使用的 API，这些新特性可能会或已经被公开使用并接受反馈中。  \n可以使用，但要谨慎。这些 API 未来可能被提升至 **维护中** 或 **稳定** 级别，但也可能不带提前通知就被移除。\n\n**维护中（Maintained）**  \n使用该 API 的特性，至少在该大版本的下一个小版本发布时不会发生向后不兼容的改变。如果未来有移除维护中 API 的计划，它会先被打回到 **已过时** 阶段。\n\n**稳定（Stable）**  \n使用该 API 的特性，至少在下个大版本发布之前不会发生向后不兼容的改变。\n\nJUnit 对外公开的类都带有一个 `@API(usage)` 注解，其中 `usage` 是上面几个值中的其中一个。团队希望这能给 API 的调用方以充足的信息，即他们所使用的 API 处于什么生命周期中，同时，也希望给每个团队以自由，让他们决定是否改变或移除过时 API 。\n\n## Open Test Alliance\n\n其实还有一件事。Junit 5 的体系结构使得 IDE 和构建工具能够将其作为中间层，以运行所有类型的测试框架（前提是该框架实现了其对应的引擎）。这样的话，工具本身就不需要去实现框架相关的测试支持，它们只需要使用一套统一的借口，即可实现测试发现、测试执行和结果收集。\n\n是嘛，真的可以吗？\n\n失败的测试，通常使用异常来描述。但不同的测试框架和断言库之间并无一个统一的接口。相反，它们通常实现了各自不同的版本（常见的是继承 `AssertionError` 或 `RuntimeException` ）。这就使得不同框架间的互操作变得更加复杂，也使得工具之间无法简单使用一套统一的接口。\n\n为了解决这个问题，Junit Lambda 团队又分出来一个独立的项目，[The Open Test Alliance for the JVM](https://github.com/ota4j-team/opentest4j)。这是它们的提议：\n\n> 基于 JUnit Lambda 团队近来与来自Eclipse、Gradle 及 Intellij 等 IDE 和构建工具开发者所展开的讨论，我们呼吁要建立这样一个开源项目：它用于提供一套基于 JVM的 测试库与测试框架 间的最小公共接口集。\n> \n> 项目主要目标是，为各测试框架（如 JUnit、TestNG、Spock 等）和三方断言库（Hamcrest、Assert 等）提供一个公共的异常集合。有了这个集合，IDE 和构建工具就可以一个统一的接口对所有测试过程——如对失败断言、失败假言判定的处理、对测试执行过程的可视化、在 IDE 中生成测试结果报告等——进行处理。\n\n截止目前，该项目的呼吁似乎并未引起太多重视，或说是基本未得到重视。如果你觉得这是个好的想法，你可以通过一些方式来支持，比如向你经常使用的测试框架维护者发出声音。\n\n## 回顾总结\n\n本篇我们介绍了 JUnit 5 的架构设计，它将原有的 API 分成了两部分：编写测试部分的 API 和 执行测试的引擎。这个引擎进一步地被切分成三个部分：一个解析测试代码的 API、一个测试执行器（launcher），和一些支持不同测试框架的引擎实现。这样开发者只需要为项目引入 API 部分的依赖（用于编写测试），而测试框架的开发者们则只需要实现引擎部分的 API（其他工作已经由 JUnit 处理了），构建工具方面也只需要实现 launcher API以协调测试执行。\n\n[下篇文章][JUnit 5: Extension Model]将会介绍 JUnit 5 的可拓展性。敬请期待。\n\n---\n\n[User guide: M2]: http://junit.org/junit5/docs/5.0.0-M2/user-guide/\n[User guide: Current]: http://junit.org/junit5/docs/current/user-guide/\n[JUnit 5: Setup]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-setup\n[JUnit 5: Basics]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-basics\n[JUnit 5: Architecture]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-architecture\n[JUnit 5: Extension Model]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-extension-model\n[JUnit 5: Conditions]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-conditions\n[JUnit 5: Injection]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-injection\n[JUnit 5: Dynamic Tests]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-dynamic-tests\n"},{"id":"2016-09-17-junit5-basics","title":"「译」JUnit 5 系列：基础入门","contents":"\n\n> 原文地址：[http://blog.codefx.org/libraries/junit-5-basics/](http://blog.codefx.org/libraries/junit-5-basics/)  \n> 原文日期：25, Feb, 2016  \n> 译文首发：[ Linesh 的博客：「译」JUnit 5 系列：基础入门](http://blog.linesh.tw/#/posts/2016-09-17-junit5-basics)  \n> 我的 Github：[http://github.com/linesh-simplicity](http://github.com/linesh-simplicity)\n\n上周我们刚刚[搭建好了 JUnit 5 的环境][JUnit 5: Setup]，现在我们可以写测试了。这节就让我们来写它几个吧！\n\n## 概述\n\n本文章是这个 JUnit 5 系列的一部分：\n\n* [环境搭建][JUnit 5: Setup]\n* [基础入门][JUnit 5: Basics]\n* [架构体系][JUnit 5: Architecture]\n* [扩展模型（Extension Model)][JUnit 5: Extension Model]\n* [条件断言][JUnit 5: Conditions]\n* 注入\n* [动态测试][JUnit 5: Dynamic Tests]\n* ...\n\n（如果不喜欢看文章，你可以[戳这里看我的演讲](http://blog.codefx.org/past-talks/)，或者[看一下最近的 vJUG 讲座](https://www.youtube.com/watch?v=ct9sIsrnE9Y)，或者[我在 DevoxxPL 上的 PPT](https://www.youtube.com/watch?v=oG80XZUN1lQ)。\n\n本系列文章都基于 Junit 5发布的先行版 [Milestone 2][User guide: M2]。它可能会有变化。如果有新的里程碑（milestone）版本发布，或者试用版正式发行时，我会再来更新这篇文章。\n\n这里要介绍的多数知识你都可以在 [JUnit 5 用户指南][User guide: M2] 中找到（这个链接指向的是先行版 Milestone 2，想看的最新版本文档的话请戳[这里][User guide: Current]），并且指南还有更多的内容等待你发掘。下面的所有代码都可以在 [我的 Github](https://github.com/CodeFX-org/demo-junit-5) 上找到。\n\n## 目录\n\n* 设计哲学\n* JUnit 5预备：\n    * 包可见性\n    * 测试的生命周期\n        * @Test\n        * Before 和 After\n        * 禁用测试\n        * 测试类的生命周期\n    * 断言\n        * 常规断言\n        * 扩展断言\n    * 假言/判定（Assumptions）\n    * 测试嵌套\n    * 测试命名\n* 回顾\n* 分享&关注\n\n## 设计哲学\n\n新的[架构设计][JUnit 5: Architecture]（这个我们日后聊），其关注点在高扩展性。如果后面出现了什么神之测试技术（至少对我们广大 Java🐶来说很神的），它们也可能在 JUnit 5 的架构下被实现。\n\n不过当前来说，涉及的基础知识与 JUnit 4 是非常相似的。JUnit 5 的改动并不激进，相反它的优化历程是小心翼翼，小步迭代的。因此，开发者应该会对新的 API 感到非常熟悉。至少我是这样的，我相信你也不会感觉陌生：\n\n```java\nclass Lifecycle {\n \n\t@BeforeAll\n\tstatic void initializeExternalResources() {\n\t\tSystem.out.println(\"Initializing external resources...\");\n\t}\n \n\t@BeforeEach\n\tvoid initializeMockObjects() {\n\t\tSystem.out.println(\"Initializing mock objects...\");\n\t}\n \n\t@Test\n\tvoid someTest() {\n\t\tSystem.out.println(\"Running some test...\");\n\t\tassertTrue(true);\n\t}\n \n\t@Test\n\tvoid otherTest() {\n\t\tassumeTrue(true);\n \n\t\tSystem.out.println(\"Running another test...\");\n\t\tassertNotEquals(1, 42, \"Why wouldn't these be the same?\");\n\t}\n \n\t@Test\n\t@Disabled\n\tvoid disabledTest() {\n\t\tSystem.exit(1);\n\t}\n \n\t@AfterEach\n\tvoid tearDown() {\n\t\tSystem.out.println(\"Tearing down...\");\n\t}\n \n\t@AfterAll\n\tstatic void freeExternalResources() {\n\t\tSystem.out.println(\"Freeing external resources...\");\n\t}\n \n}\n```\n\n是吧？这里并没有很大的改动。\n\n## JUnit 5 预备\n\n### 包可见性\n\n JUnit 5 最明显的变化应该是，不再需要手动将测试类与测试方法为 `public` 了。包可见的访问级别就足够了。当然，私有（private）访问还是不行的。我认为这个变化是合理的，也符合我们对可见性的一般直觉。\n\n这很好！至少可以少打几个字母了。不过，我相信你也不是每次都手打这几个字母的，是吧？尽管如此还是很好，少一些关键字，你在看测试的时候也少些切换。\n\n### 测试的生命周期\n\n#### @Test\n\nJUnit 中最基本的注解非 `@Test` 莫属了。它会标记方法为测试方法，以便构建工具和 IDE 能够识别并执行它们。\n\n它的 API 和作用并没有变化，不过它不再接受任何参数了。若要测试是否[抛出异常](http://junit.org/junit4/javadoc/latest/org/junit/Test.html#expected%28%29)，你可以通过新的[断言 API ](http://blog.codefx.org/libraries/junit-5-basics/#assertions)来做到；不过就我所知，目前还没有[超时选项timeout](http://junit.org/junit4/javadoc/latest/org/junit/Test.html#timeout%28%29)的替代品。\n\n与 JUnit 4一样，JUnit 5 会为每个测试方法创建一个新的实例。\n\n#### Before 和 After\n\n你可能需要执行一些代码来在测试执行前后完成一些初始化或销毁的操作。在 JUnit 5 中，有4个注解你可能会用于如此工作：\n\n`@BeforeAll`  \n只执行一次，执行时机是在所有测试和 `@BeforeEach` 注解方法之前。\n\n`@BeforeEach`  \n在每个测试执行之前执行。\n\n`@AfterEach`  \n在每个测试执行之后执行。\n\n`@AfterAll`  \n只执行一次，执行时机是在所有测试和 `@AfterEach` 注解方法之后。\n\n因为框架会为每个测试创建一个单独的实例，在 `@BeforeAll`/`@AfterAll` 方法执行时尚无任何测试实例诞生。因此，这两个方法必须定义为静态方法。\n\n注解了同样一个注解的不同方法，其执行次序是不可预知的，包括对继承来的方法也适用。这是开发团队经过审慎思考后的决定，即把单元测试与集成测试的关注点分开。集成测试可能需要方法间更紧密的协作，但一个单元测试不应该对其他的单元测试有所依赖。而对于集成测试——也叫场景测试——的支持，也[已在团队的计划中](https://github.com/junit-team/junit5/issues/48)。\n\n除了名字有所不同，这几个注解与 JUnit 4 中的注解工作方式完全一样。[无独有偶](http://jasmine.github.io/2.1/introduction.html#section-Setup_and_Teardown)，[跟主流意见一致](https://www.relishapp.com/rspec/rspec-core/v/2-2/docs/hooks/before-and-after-hooks)，我也觉得这个新的命名不能说服我其必要性。[这个 issue](https://github.com/junit-team/junit5/issues/163) 下有更多的讨论。\n\n#### 禁用测试\n\n今儿星期五，抬头一看已经4点半，无心工作的你想回家了？完全理解，在测试上怒拍一个 `@Disabled` 注解即可。~~有良心的话~~写个忽略测试的理由是极好的，不过也可以不带此参数。\n\n```java\n@Test \n@Disabled(\"你丫就是存心跑不过的是不？！\")\nvoid failingTest() {\n    assertTrue(false);\n}\n```\n\n#### 测试类的生命周期\n\nJUnit 团队发布的第一版原型中，包含了一个对 [测试类的生命周期](http://blog.codefx.org/libraries/junit-lambda-prototype/#Lifecycles) 的描述，有意思的是，这个特性在 alpha 版本的发布中未被加入。这个生命周期模型建议，在被测类的多个测试方法中使用一个同样的实例，因为这样我们就可以通过改变对象的状态，进而实现在多个测试方法中的交互。（我也再说一遍，这更像是 [场景测试](https://github.com/junit-team/junit5/issues/48) 要管的事。）\n\n正如我在第一版公测时所说，这样的特性99%的场景下是有害的，只有另外1%的场合下才有真正的用处。我只能说，还好这个特性被摒弃了。想想你的单元测试，如果它们必须靠在方法间维护状态来工作，这画面简直太美我不敢看🙈。\n\n### 断言\n\n如果说 `@Test`、`@Before...`、`@After...` 等注解是一个测试套件的骨架，那么断言就是它的心脏。准备好测试实例、执行了被测类的方法以后，断言能确保你得到了想要的结果。否则，就说明当前测试失败了。\n\n#### 常规断言\n\n一般的断言，无非是检查一个实例的属性（比如，判空与判非空等），或者对两个实例进行比较（比如，检查两个实例对象是否相等）等。无论哪种检查，断言方法都可以接受一个字符串作为最后一个可选参数，它会在断言失败时提供必要的描述信息。如果提供出错信息的过程比较复杂，它也可以被包装在一个 lambda 表达式中，这样，只有到真正失败的时候，消息才会真正被构造出来。\n\n```java\n\n@Test\nvoid assertWithBoolean() {\n\tassertTrue(true);\n\tassertTrue(this::truism);\n \n\tassertFalse(false, () -> \"Really \" + \"expensive \" + \"message\" + \".\");\n}\n \nboolean truism() {\n\treturn true;\n}\n \n@Test\nvoid assertWithComparison() {\n\tList<String> expected = asList(\"element\");\n\tList<String> actual = new LinkedList<>(expected);\n \n\tassertEquals(expected, actual);\n\tassertEquals(expected, actual, \"Should be equal.\");\n\tassertEquals(expected, actual, () -> \"Should \" + \"be \" + \"equal.\");\n\t\n\tassertNotSame(expected, actual, \"Obviously not the same instance.\");\n}\n```\n\n如你所见，JUnit 5 的 API 并无太多变化。断言方法的命名是一样的，方法同样接受两个参数，分别是一个期望值与一个实际值。\n\n期望值与实际值的传入顺序非常重要，无论是对于理解测试的内容，还是理解失败时的错误信息，但有时还是很容易弄错，这点很坑。不过仔细想想，也没什么更好的办法，除非你自己创建一个新的断言框架。既然市面上已有对应的产品如 [Hamcrest](http://hamcrest.org/JavaHamcrest/) (ugh!) 和 [AssertJ](http://joel-costigliola.github.io/assertj/) (yeah！译者表示：不太清楚这欢呼的梗在哪里)等，再浪费有限的时间去造轮子明显不值得。毕竟最重要的是保证你的断言库专注于一件事，借鉴已有实现可以节省成本。\n\n哦对了，失败信息现在是作为最后传入的参数了。我很喜欢这个细节，因为，它让你专注于真正重要之事——那两个需被断言的值。由于拥抱了 Java 8 的缘故，真值断言方法现在也接受 [`supplier`](https://docs.oracle.com/javase/8/docs/api/java/util/function/BooleanSupplier.html) 参数了，又是一个暖心的小细节。\n\n#### 扩展断言\n\n除了那种一般的检查特定实例或属性的断言外，还有一些其他类型的断言。\n\n这里要讲的第一个甚至都不是个真正的断言，它做的事就是强行让测试失败，并提供一个失败信息。\n\n```java\n@Test\nvoid failTheTest() {\n\tfail(\"epicly\");\n}\n```\n\n还有 `assertAll` 方法，它接受可变数量的断言作为参数，并保证它们全部得到执行，然后再把错误信息（如果有）一并汇报出来。\n\n```java\n@Test\nvoid assertAllProperties() {\n\tAddress address = new Address(\"New City\", \"Some Street\", \"No\");\n \n\tassertAll(\"address\",\n\t\t\t() -> assertEquals(\"Neustadt\", address.city),\n\t\t\t() -> assertEquals(\"Irgendeinestraße\", address.street),\n\t\t\t() -> assertEquals(\"Nr\", address.number)\n\t);\n}\n```\n\n```\norg.opentest4j.MultipleFailuresError: address (3 failures)\n\texpected: <Neustadt> but was: <New City>\n\texpected: <Irgendeinestraße> but was: <Some Street>\n\texpected: <Nr> but was: <No>\n```\n\n这个特性在检查对象的多个属性值时非常有用。按照一般的做法，测试在第一个断言失败时就会挂掉了，此时只有第一个出错的地方得到提示，而你无法得知其他值的断言是否成功，只好再跑一遍测试。\n\n最后，我们终于有了 `assertThrows` 和 `expectThrows` 方法。两者均会在被测方法未抛出预期异常时失败。而后者还会返回抛出的异常实例，以用于后续的验证，比如，断言异常信息包含正确的信息等。\n\n```java\n@Test\nvoid assertExceptions() {\n\tassertThrows(Exception.class, this::throwing);\n \n\tException exception = expectThrows(Exception.class, this::throwing);\n\tassertEquals(\"Because I can!\", exception.getMessage());\n}\n```\n\n### 假言/判定（Assumptions） \n假言/判定允许你仅在特定条件满足时才运行测试。这个特性能够减少测试组件的运行时间和代码重复，特别是在假言都不满足的情况下。\n\n```java\n\n@Test\nvoid exitIfFalseIsTrue() {\n\tassumeTrue(false);\n\tSystem.exit(1);\n}\n \n@Test\nvoid exitIfTrueIsFalse() {\n\tassumeFalse(this::truism);\n\tSystem.exit(1);\n}\n \nprivate boolean truism() {\n\treturn true;\n}\n \n@Test\nvoid exitIfNullEqualsString() {\n\tassumingThat(\n\t\t\t\"null\".equals(null),\n\t\t\t() -> System.exit(1)\n\t);\n}\n```\n\n假言/判定适用于两种情形，要么是你希望在某些条件不满足时中止测试，要么是你希望仅当某个条件满足时才执行（部分）测试。主要的区别是，被中止的测试是以被禁用（disabled）的形式被报告，此时没有测试任何内容，因为条件得不到满足。\n\n### 测试嵌套\n\n在 JUnit 5 中，嵌套测试几乎不费吹灰之力。你只需要在嵌套的类上添加 `@Nested` 注解，类中的所有方法即会被引擎执行：\n\n```java\n\npackage org.codefx.demo.junit5;\n \nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n \nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n \nclass Nest {\n\t\n\tint count = Integer.MIN_VALUE;\n\t\n\t@BeforeEach\n\tvoid setCountToZero() {\n\t\tcount = 0;\n\t}\n\t\n\t@Test\n\tvoid countIsZero() {\n\t\tassertEquals(0, count);\n\t}\n\t\n\t@Nested\n\tclass CountGreaterZero {\n \n\t\t@BeforeEach\n\t\tvoid increaseCount() {\n\t\t\tcount++;\n\t\t}\n \n\t\t@Test\n\t\tvoid countIsGreaterZero() {\n\t\t\tassertTrue(count > 0);\n\t\t}\n \n\t\t@Nested\n\t\tclass CountMuchGreaterZero {\n \n\t\t\t@BeforeEach\n\t\t\tvoid increaseCount() {\n\t\t\t\tcount += Integer.MAX_VALUE / 2;\n\t\t\t}\n \n\t\t\t@Test\n\t\t\tvoid countIsLarge() {\n\t\t\t\tassertTrue(count > Integer.MAX_VALUE / 2);\n\t\t\t}\n \n\t\t}\n \n\t}\n\t\n}\n```\n\n如你所见，嵌套类中的 `@BeforeEach`（及 `@AfterEach` ）注解也工作良好。不过，构造顺序似乎还未被写入文档，它们的初始化次序是从外向内的。这也让你能叠加式地为内部类准备测试数据。\n\n如果嵌套的内部测试想要存取外部测试类的字段，那么嵌套类本身不应该是静态的。但这样一来也就禁止了静态方法的使用，因而这种场景下`@BeforeAll` 和 `@AfterAll` 方法也就无法使用了（[还是说终有他法实现？](https://github.com/junit-team/junit5/issues/166)）\n\n你可能有疑惑，嵌套的内部测试类有什么用。个人而言，我用内部类来[渐进测试接口](https://github.com/CodeFX-org/LibFX/blob/3ec42447a99cbac33642cef35d0e522f7b595435/src/test/java/org/codefx/libfx/collection/tree/stream/StackTreePathTest.java)，其他人则多用于保持测试类[短小专注](http://www.petrikainulainen.net/programming/testing/writing-clean-tests-small-is-beautiful/)。后者同时也有一个经典的例子来说明，[例子由 JUnit 团队提供](https://junit-team.github.io/junit5/#nested-tests)，它测试了一个栈：\n\n```java\nclass TestingAStack {\n \n    Stack<Object> stack;\n    boolean isRun = false;\n \n    @Test\n    void isInstantiatedWithNew() {\n        new Stack<Object>();\n    }\n \n    @Nested\n    class WhenNew {\n \n        @BeforeEach\n        void init() {\n            stack = new Stack<Object>();\n        }\n \n        // some tests on 'stack', which is empty\n \n        @Nested\n        class AfterPushing {\n \n            String anElement = \"an element\";\n \n            @BeforeEach\n            void init() {\n                stack.push(anElement);\n            }\n \n            // some tests on 'stack', which has one element...\n \n        }\n    }\n}\n```\n\n在上面的例子中，栈的状态改变会反映到内层的测试类中，其中内部类又基于自身的场景执行了一些测试。\n\n### 测试命名\n\nJUnit 5 提供了一个注解 `@DisplayName`，它用以为开发者提供更可读的测试类和测试方法信息。\n\n上面的 stack 测试例子加上该注解以后就变成这样：\n\n```java\n@DisplayName(\"A stack\")\nclass TestingAStack {\n \n    @Test\n    @DisplayName(\"is instantiated with new Stack()\")\n    void isInstantiatedWithNew() { /*...*/ }\n \n    @Nested\n    @DisplayName(\"when new\")\n    class WhenNew {\n \n        @Test\n        @DisplayName(\"is empty\")\n        void isEmpty() { /*...*/ }\n \n        @Test\n        @DisplayName(\"throws EmptyStackException when popped\")\n        void throwsExceptionWhenPopped() { /*...*/ }\n \n        @Test\n        @DisplayName(\"throws EmptyStackException when peeked\")\n        void throwsExceptionWhenPeeked() { /*...*/ }\n \n        @Nested\n        @DisplayName(\"after pushing an element\")\n        class AfterPushing {\n \n            @Test\n            @DisplayName(\"it is no longer empty\")\n            void isEmpty() { /*...*/ }\n \n            @Test\n            @DisplayName(\"returns the element when popped and is empty\")\n            void returnElementWhenPopped() { /*...*/ }\n \n            @Test\n            @DisplayName(\n                    \"returns the element when peeked but remains not empty\")\n            void returnElementWhenPeeked(){ /*...*/ }\n        }\n    }\n}\n```\n\n这是一份TDDer 看了会感动，[BDD](http://dannorth.net/introducing-bdd/)er 看了会流泪的测试结果输出。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/junit-5-basics-testing-a-stack.png)\n\n\n## 回顾\n\n差不多就这些了，恭喜你终于读完了。我们匆匆过完了 JUnit 5 的基本特性，现在，你应该了解了所有写测试的必备知识了：包括如何为方法添加生命周期注解（`@[Before|After][All|Each]`、如何注解测试方法本身（`@Test`）、如何嵌套测试（`@Nested`）、如何给测试一个好信息（`@DisplayName`），你也应该能了解断言和假言判定是如何工作的了（基本上与前版无异）。\n\n不过这可还没完！我们还没聊到 [测试方法的条件执行][JUnit 5: Conditions]，没聊到非常酷的 [参数注入][JUnit 5: Injection] ，以及 [JUnit 5 的扩展机制][JUnit 5: Extension Model] 和 [架构体系][JUnit 5: Architecture] 呢。放心，这真的是最后了，这些话题我们会一个月后再聊，现在你可以先休息一下啦。\n\n敬请期待下集！\n\n---\n\n[User guide: M2]: http://junit.org/junit5/docs/5.0.0-M2/user-guide/\n[User guide: Current]: http://junit.org/junit5/docs/current/user-guide/\n[JUnit 5: Setup]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-setup\n[JUnit 5: Basics]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-basics\n[JUnit 5: Architecture]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-architecture\n[JUnit 5: Extension Model]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-extension-model\n[JUnit 5: Conditions]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-conditions\n[JUnit 5: Injection]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-injection\n[JUnit 5: Dynamic Tests]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-dynamic-tests\n"},{"id":"2016-09-17-junit5-conditions","title":"「译」JUnit 5 系列：条件测试","contents":"\n\n> 原文地址：[http://blog.codefx.org/libraries/junit-5-conditions/](http://blog.codefx.org/libraries/junit-5-conditions/)  \n> 原文日期：08, May, 2016  \n> 译文首发：[ Linesh 的博客：「译」JUnit 5 系列：条件测试](http://blog.linesh.tw/#/posts/2016-09-17-junit5-conditions)  \n> 我的 Github：[http://github.com/linesh-simplicity](http://github.com/linesh-simplicity)\n\n上一节我们了解了 JUnit 新的[扩展模型][JUnit 5: Extension Model]，了解了它是如何支持我们向引擎定制一些行为的。然后我还预告会为大家讲解条件测试，这一节主题就是它了。\n\n条件测试，指的是允许我们自定义灵活的标准，来决定一个测试是否应该执行。条件（condition） 官方的叫法是[条件测试执行](http://junit.org/junit5/docs/current/user-guide/#conditional-test-execution)。\n\n## 概述\n\n* [环境搭建][JUnit 5: Setup]\n* [基础入门][JUnit 5: Basics]\n* [架构体系][JUnit 5: Architecture]\n* [扩展模型（Extension Model)][JUnit 5: Extension Model]\n* [条件断言][JUnit 5: Conditions]\n* 注入\n* [动态测试][JUnit 5: Dynamic Tests]\n* ...\n\n（如果不喜欢看文章，你可以[戳这里看我的演讲](http://blog.codefx.org/past-talks/)，或者[看一下最近的 vJUG 讲座](https://www.youtube.com/watch?v=ct9sIsrnE9Y)，或者[我在 DevoxxPL 上的 PPT](https://www.youtube.com/watch?v=oG80XZUN1lQ)。\n\n本系列文章都基于 Junit 5发布的先行版 [Milestone 2][User guide: M2]。它可能会有变化。如果有新的里程碑（milestone）版本发布，或者试用版正式发行时，我会再来更新这篇文章。\n\n这里要介绍的多数知识你都可以在 [JUnit 5 用户指南][User guide: M2] 中找到（这个链接指向的是先行版 Milestone 2，想看的最新版本文档的话请戳[这里][User guide: Current]），并且指南还有更多的内容等待你发掘。下面的所有代码都可以在 [我的 Github](https://github.com/CodeFX-org/demo-junit-5) 上找到。\n\n## 目录\n\n* 相关的扩展点\n* 动手实现一个@Disabled 注解\n* @DisabledOnOs\n    * 一种简单的实现方式\n    * 更简洁的API\n    * 代码重构\n* @DisabledIfTestFails\n    * 异常收集\n    * 禁用测试\n    * 集成\n* 回顾总结\n* 分享&关注\n\n## 相关的扩展点\n\n还记得 [拓展点][JUnit 5: Extension Model] 一节讲的内容吗？不记得了？好吧，简单来说，JUnit 5 中定义了许多扩展点，每个扩展点都对应一个接口。你自己的扩展可以实现其中的某些接口，然后通过 `@ExtendWith` 注解注册给 JUnit，后者会在特定的时间点调用你的接口实现。\n\n要实现条件测试，你需要关注其中的两个扩展点： `ContainerExecutionCondition` （容器执行条件）和 `TestExecutionCondition` （测试执行条件）。\n\n```java\npublic interface ContainerExecutionCondition extends Extension {\n \n\t/**\n\t * Evaluate this condition for the supplied ContainerExtensionContext.\n\t *\n\t * An enabled result indicates that the container should be executed;\n\t * whereas, a disabled result indicates that the container should not\n\t * be executed.\n\t *\n\t * @param context the current ContainerExtensionContext; never null\n\t * @return the result of evaluating this condition; never null\n\t */\n\tConditionEvaluationResult evaluate(ContainerExtensionContext context);\n \n}\n \npublic interface TestExecutionCondition extends Extension {\n \n\t/**\n\t * Evaluate this condition for the supplied TestExtensionContext.\n\t *\n\t * An enabled result indicates that the test should be executed;\n\t * whereas, a disabled result indicates that the test should not\n\t * be executed.\n\t *\n\t * @param context the current TestExtensionContext; never null\n\t * @return the result of evaluating this condition; never null\n\t */\n\tConditionEvaluationResult evaluate(TestExtensionContext context);\n \n}\n```\n\n`ContainerExecutionCondition` 接口将决定容器中的测试是否会被执行。通常情况下，你使用 `@Test` 注解来标记测试，此时测试所在的类就是容器。同时，单独的测试方法是否执行则是由 `TestExecutionCondition` 接口决定的。\n\n（这里，我说的是“通常情况下”，因为其他[测试引擎][JUnit 5: Architecture]可能对容器和测试有截然不同的定义。但一般情况下，测试就是单个的方法，容器指的就是测试类。）\n\n嗯，基本知识就这么多。想实现条件测试，至少需要实现以上两个接口中的一个，并在接口的 `evalute` 方法中执行自己的条件检查。\n\n## 动手实现一个@Disabled 注解\n\n最简单的“条件”就是判断都没有，直接禁用测试。如果在方法上发现了 `@Disabled` 注解，我们就直接禁用该测试。\n\n让我们来写一个这样的 `@Disabled` 注解吧：\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@ExtendWith(@DisabledCondition.class)\npublic @interface Disabled { }\n```\n\n对应的扩展如下：\n\n```java\npublic class DisabledCondition\n\t\timplements ContainerExecutionCondition, TestExecutionCondition {\n \n\tprivate static final ConditionEvaluationResult ENABLED =\n\t\t\tConditionEvaluationResult.enabled(\"@Disabled is not present\");\n \n\t@Override\n\tpublic ConditionEvaluationResult evaluate(\n\t\t\tContainerExtensionContext context) {\n\t\treturn evaluateIfAnnotated(context.getElement());\n\t}\n \n\t@Override\n\tpublic ConditionEvaluationResult evaluate(\n\t\t\tTestExtensionContext context) {\n\t\treturn evaluateIfAnnotated(context.getElement());\n\t}\n \n\tprivate ConditionEvaluationResult evaluateIfAnnotated(\n\t\t\tOptional<AnnotatedElement> element) {\n\t\tOptional<Disabled> disabled = AnnotationUtils\n\t\t\t\t.findAnnotation(element, Disabled.class);\n \n\t\tif (disabled.isPresent())\n\t\t\treturn ConditionEvaluationResult\n\t\t\t\t\t.disabled(element + \" is @Disabled\");\n \n\t\treturn ENABLED;\n\t}\n\n}\n```\n\n写起来小菜一碟吧？在 JUnit [真实的产品代码](https://github.com/junit-team/junit5/blob/9e846af07b1941c50f34da733584b9d0664ec968/junit5-engine/src/main/java/org/junit/gen5/engine/junit5/extension/DisabledCondition.java)中，`@Disabled` 也是这么[实现的](https://github.com/junit-team/junit5/blob/9e846af07b1941c50f34da733584b9d0664ec968/junit5-engine/src/main/java/org/junit/gen5/engine/junit5/extension/DisabledCondition.java)。不过，有两个地方有一些细微的差别：\n\n* 官方 `@Disabled` 注解不需要再使用 `@ExtendWith` 注册扩展，因为它是默认注册了的\n* 官方 `@Disabled` 注解可以接收一个参数，解释测试被忽略的理由。它会在测试被忽略时被记录下来\n\n使用时请注意，`AnnotationUtils` 是个内部 API。不过，官方[可能很快](https://github.com/junit-team/junit5/issues/246)就会将它提供的功能给[开放出来](https://github.com/junit-team/junit5/issues/246)。\n\n接下来让我们写点更有意思的东西吧。\n\n## @DisabledOnOs\n\n如果有些测试我们只想让它在特定的操作系统上面运行，这个要怎么实现呢？\n\n### 一种简单的实现方式\n\n当然，我们还是从注解开始咯：\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@ExtendWith(OsCondition.class)\npublic @interface DisabledOnOs {\n \n\tOS[] value() default {};\n \n}\n```\n\n这回注解需要接收一个或多个参数值，你需要告诉它想禁用测试的操作系统有哪些。 `OS` 是个枚举类，定义了所有操作系统的名字。同时，它还提供了一个静态的 `static OS determine()` 方法，你可能已经从名字猜到了，它会推断并返回你当前所用的操作系统。\n\n现在我们可以着手实现 `OsCondition` 扩展类了。它必须检查两点：注解是否存在，以及当前操作系统是否在注解声明的禁用列表中。\n\n```java\npublic class OsCondition \n\t\timplements ContainerExecutionCondition, TestExecutionCondition {\n \n\t// both `evaluate` methods forward to `evaluateIfAnnotated` as above\n \n\tprivate ConditionEvaluationResult evaluateIfAnnotated(\n\t\t\tOptional<AnnotatedElement> element) {\n\t\tOptional<DisabledOnOs> disabled = AnnotationUtils\n\t\t\t\t.findAnnotation(element, DisabledOnOs.class);\n \n\t\tif (disabled.isPresent())\n\t\t\treturn disabledIfOn(disabled.get().value());\n \n\t\treturn ENABLED;\n\t}\n \n\tprivate ConditionEvaluationResult disabledIfOn(OS[] disabledOnOs) {\n\t\tOS os = OS.determine();\n\t\tif (Arrays.asList(disabledOnOs).contains(os))\n\t\t\treturn ConditionEvaluationResult\n\t\t\t\t\t.disabled(\"Test is disabled on \" + os + \".\");\n\t\telse\n\t\t\treturn ConditionEvaluationResult\n\t\t\t\t\t.enabled(\"Test is not disabled on \" + os + \".\");\n\t}\n\n}\n``` \n\n然后使用的时候就可以像这样：\n\n```java\n@Test\n@DisabledOnOs(OS.WINDOWS)\nvoid doesNotRunOnWindows() {\n    assertTrue(false);\n}\n```\n\n棒。\n\n### 更简洁的API\n\n但代码还可以写得更好！[JUnit 的注解是可组合的](http://blog.codefx.org/design/architecture/junit-5-extension-model/#Custom-Annotations)，基于此我们可以让这个条件注解更简洁：\n\n```java\n@TestExceptOnOs(OS.WINDOWS)\nvoid doesNotRunOnWindowsEither() {\n\tassertTrue(false);\n}\n```\n\n`@TestExceptionOnOs`完美的实现方案是这样的：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Test\n@DisabledOnOs(/* 通过某种方式取得注解下的 `value` 值 */)\npublic @interface TestExceptOnOs {\n \n\tOS[] value() default {};\n \n}\n```\n\n测试实际运行时， `OsCondition::evaluateIfAnnotated` 方法会扫描 `@DisabledOnOs` 注解，然后我们发现它又是对 `@TestExceptOnOs` 的注解，前面写的代码就可以如期工作了。但我不知道如何在 `@DisabledOnOs` 注解中获取 `@TestExceptOnOs` 中的`value()`值。:(（你能做到吗？）\n\n次佳的选择是，简单地在 `@TestExceptOnOs` 注解上直接声明应用的扩展就可以了：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@ExtendWith(OsCondition.class)\n@Test\npublic @interface TestExceptOnOs {\n \n\tOS[] value() default {};\n \n}\n```\n\n然后直接把 `OsCondition:evaluateIfAnnotated` 方法拉过来改改即可：\n\n```java\nprivate ConditionEvaluationResult evaluateIfAnnotated(\n        Optional<Annotatedelement> element) {\n    Optional<DisabledOnOs> disabled = AnnotationUtils\n        .findAnnotation(element, DisabledOnOs.class);\n    if (disabled.isPresent()) \n        return disabledIfOn(disabled.get().value());\n        \n    Optional<TestExceptOnOs> testExcept = AnnotationUtils\n        .findAnnotation(element, TestExceptOnOs.class);\n    if (testExcept.isPresent()) \n        return disabledIfOn(testExcept.get().value());\n            \n    return ConditionEvaluationResult.enabled(\"\");\n}\n```\n\n收工。现在我们可以如期使用这个注解了。\n\n### 代码重构\n\n我们还需要创建一个意义刚好相反的注解（即现在变为，当前操作系统不在提供列表时，才禁用测试），工作是类似的，但是注解名会更表意，再加入静态导入后，我们的代码最终可以整理成这样：\n\n```java\n@TestOn(WINDOWS)\nvoid doesNotRunOnWindoesEither() {\n    assertTrue(false);\n}\n```\n\n还挺好看的，是不？\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/junit-5-conditions.jpg)\n\n「译者注：英文中condition有多个意思：“条件；空调”。作者这里配图取双关」\n\n## @DisabledIfTestFails\n\n我们再考虑一种场景——我保证这次可以接触更有意思的东西！假设现在有许多（集成）测试，如果其中有一个抛出了特定的异常而失败，那么其他测试也必须会挂。为了节省时间，我们希望在这种情况下直接禁用掉其他的测试。\n\n那么我们需要做些什么工作呢？首先第一反应不难想到，我们 必须先能收集测试执行过程抛出的异常。这肯定需要在单个测试类级别的生命周期中进行处理，否则就可能因为其他测试类中抛出的异常而影响到本测试类的运行。其次，我们需要一个实现一个条件：它会检查某个特定的异常是否已被抛出过，若是，禁用当前测试。\n\n### 异常收集\n\n翻阅一下文档中提供的 [扩展点列表](http://blog.codefx.org/design/architecture/junit-5-extension-model/#Extension-Points)，不难发现有一项“异常处理”，看起来就是我们想要的东西：\n\n```java\n/**\n * TestExecutionExceptionHandler defines the API for Extensions that wish to react to thrown exceptions in tests.\n * \n * [ ... ]\n */\npublic interface TestExecutionExceptionHandler extends ExtensionPoint { \n    /**\n     * Handle the supplied throwable.\n     * \n     * Implementors must perform one of the following.\n     * \n     * - Swallow the supplied throwable, thereby preventing propagation\n     * - Rethrow the incoming throwable as is \n     * - Throw a new exception, potenially wrapping the supplied throwable \n     *  \n     * [ ... ]\n     */\n    void handleTestExecutionException(\n        TestExtensionContext context, Throwable throwable) \n        throws Throwable;    \n}\n```\n\n读完发现，我们的任务就是实现 `handleException` 方法，存储起接收到的异常并重新抛出。\n\n你可能还记得我提过的关于扩展点和无状态的一些结论：\n\n> 引擎对扩展实例的初始化时间、实例的生存时间未作出任何规约和保证，因此，扩展必须是无状态的。如果一个扩展需要维持任何状态信息，那么它必须使用 JUnit 提供的一个仓库（store）来进行信息读取和写入。\n\n看来我们是必须使用这个 store 了。store 其实就是存放我们希望保存的一些东西，一个可索引的资源集合。它可以在扩展上下文对象中取得，后者会被传给大多数扩展点接口方法作为参数。不过需要注意的是，每个不同的上下文对象都有自己一个独立的 store，所以我们还必须决定使用哪个 store。\n\n每个测试方法有一个自己的上下文对象（`TestExtensionContext`），同时，测试类也有一个自己的上下文对象（`ContainerExtensionContext`）。还记得我们的需求吗？保存测试类中任何测试方法可能抛出的异常，仅此而已。也即，我们不会保存其他测试类中抛出的异常。这样一来，容器级别的上下文 `ContainerExtensionContext` 刚好就是我们需要的了。\n\n接下来，我们可以使用这个容器上下文，通过它来存储所有测试过程抛出的异常：\n\n```java\nprivate static final Namespece NAMESPACE = Namespace\n    .of(\"org\", \"codefx\", \"CollectExceptions\");\nprivate static final String THROWN_EXCEPTIONS_KEY = \"THROWN_EXCEPTION_KEY\";\n\n@SuppressWarnings(\"unchecked\")\nprivate static Set<Exception> getThrown(ExtensionContext context) {\n    ExtensionContext containerContext = getAncestorContainerContext(context)\n        .orElseThrow(IllegalStateException::new);\n    retrun (Set<Exception>) containerContext\n        .getStore(NAMESPACE)\n        .getOrComputeIfAbsent(\n            THROWN_EXCEPTIONS_KEY,\n            ignoredKey -> new HashSet<>());\n}\n\nprivate static Optional<ExtensionContext> getAncestorContainerContext(\n        ExtensionContext context) {\n    Optional<ExtensionContext> containerContext = Optional.of(context);\n    while (containerContext.isPresent()) \n            && !(containerContext.get() instanceof ContainerExtenstionContext)) \n        containerContext = containerContext.get().getParent();\n    return containerContext;\n}\n```\n\n现在存储一个异常就非常简单了：\n\n```java\n@Override\npublic void handleException(TestExtensionContext context, Throwable throwable) \n        throws Throwable {\n    if (throwable instanceof Exception) {\n        getThrown(context).add((Exception) throwable);\n    throw throwable;\n```\n\n有意思的是，这个扩展还是自扩展的，没准还可以用来做数据统计呢「译者注：这句不太理解，原文 This is actually an interesting extension of its own. Maybe it could be used for analytics as well.」。不管怎样，我们需要一个public方法来拿到已抛出的异常列表：\n\n```java\npublic static Stream<Exception> getThrownExceptions(\n        ExtensionContext context) {\n    return getThrown(context).stream();\n}    \n```\n\n有了这个方法，其他的扩展就可以检查至今为止所抛出的异常列表了。\n\n### 禁用测试\n\n禁用测试的部分与前节所述十分类似，我们可以很快写出代码：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@ExtendWith(DisabledIfTestFailedCondition.class)\npublic @interface DisabledIfTestFailedWith {\n\n    Class <? extends Exception>[] value() default {};\n\n}\n```\n\n注意，现在仅允许该注解被用在测试方法上。应用在测试类上也说得过去，不过我们现在先不把它复杂化。因此我们只需要实现接口`TestExecutionCondition`即可。我们先检查注解是否存在，若是，再拿到用户提供的异常类作为参数，调用 `disableIfExceptionWasThrown`。\n\n```java\nprivate ConditionEvaluationResult disableIfExceptionWasThrown(\n        TestExtensionContext context,\n        Class<? extends Exception>[] exceptions) {\n    return Arrays.stream(exceptions)\n            .filter(ex -> wasThrown(context, ex))\n            .findAny().\n            .map(thrown -> ConditionEvaluationResult.disabled(\n                    thrown.getSimpleName() + \"was thrown.\"))\n            .orElseGet(() -> ConditionEvaluationResult.enabled(\"\"));\n}\n\nprivate static boolean wasThrown(\n        TestExtensionContext context, Class<? extends Exception> exception) {\n    return CollectExceptionExtension.getThrownExceptions(context)\n            .map(Object::getClass)\n            .anyMatch(exception::isAssignableFrom);\n}    \n```\n\n### 集成\n\n至此为止需求完成。现在我们可以使用这个注解，在某个特定类型的异常抛出时禁用测试了：\n\n```java\n@CollectExceptions\nclass DisabledIfFailsTest {\n    \n    private static boolean failedFirst = false;\n    \n    @Test\n    void throwException() {\n        System.out.println(\"I failed!\");\n        failedFirst = true;\n        throw new RuntimeException();\n    }\n    \n    @Test\n    @DisabledIfTestFailedWith(RuntimeException.class)\n    void disableIfOtherFailedFirst() {\n        System.out.println(\"Nobody failed yet! (Right?)\");\n        assertFalse(failedFirst);\n    }\n    \n}\n```\n\n## 回顾总结\n\n哇哦，本篇的代码还挺多的！不过相信到此你已经能完全理解怎么在 JUnit 5 中实现条件测试了：\n\n* 创建一个注解，并使用 `@ExtendWith` 注解它，然后提供你自己实现的条件类\n* 实现 `ContainerExecutionCondition` 或/和 `TestExecutionCondition`\n* 检查测试类上是否应用了你新创建的注解\n* 检查特定条件是否实现，并返回结果\n\n除此以外，我们还看到注解之间可以组合，学到如何使用 JUnit 提供的 store 来保存数据，以及一个扩展的实现，如何通过自定义注解的加入变得更加优雅。\n\n更多关于 ~~[旗帜](https://www.youtube.com/watch?v=_e8PGPrPlwA)~~ 扩展点的故事「译者注：原文为more fun with ~~flag~~ extension points，more fun with flags 是生活大爆炸中谢耳朵讲国旗的故事一部」，请参考下篇文章，我们会探讨关于参数注入的问题。\n\n---\n\n[User guide: M2]: http://junit.org/junit5/docs/5.0.0-M2/user-guide/\n[User guide: Current]: http://junit.org/junit5/docs/current/user-guide/\n[JUnit 5: Setup]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-setup\n[JUnit 5: Basics]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-basics\n[JUnit 5: Architecture]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-architecture\n[JUnit 5: Extension Model]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-extension-model\n[JUnit 5: Conditions]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-conditions\n[JUnit 5: Injection]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-injection\n[JUnit 5: Dynamic Tests]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-dynamic-tests\n"},{"id":"2016-09-17-junit5-extension-model","title":"「译」JUnit 5 系列：扩展模型（Extension Model）","contents":"\n\n> 原文地址：[http://blog.codefx.org/design/architecture/junit-5-extension-model/](http://blog.codefx.org/design/architecture/junit-5-extension-model/)  \n> 原文日期：11, Apr, 2016  \n> 译文首发：[ Linesh 的博客：「译」JUnit 5 系列：扩展模型（Extension Model）](http://blog.linesh.tw/#/posts/2016-09-17-junit5-extension-model)  \n> 我的 Github：[http://github.com/linesh-simplicity](http://github.com/linesh-simplicity)\n\n## 概述\n\n* [环境搭建][JUnit 5: Setup]\n* [基础入门][JUnit 5: Basics]\n* [架构体系][JUnit 5: Architecture]\n* [扩展模型（Extension Model)][JUnit 5: Extension Model]\n* [条件断言][JUnit 5: Conditions]\n* 注入\n* [动态测试][JUnit 5: Dynamic Tests]\n* ...\n\n（如果不喜欢看文章，你可以[戳这里看我的演讲](http://blog.codefx.org/past-talks/)，或者[看一下最近的 vJUG 讲座](https://www.youtube.com/watch?v=ct9sIsrnE9Y)，或者[我在 DevoxxPL 上的 PPT](https://www.youtube.com/watch?v=oG80XZUN1lQ)。\n\n本系列文章都基于 Junit 5发布的先行版 [Milestone 2][User guide: M2]。它可能会有变化。如果有新的里程碑（milestone）版本发布，或者试用版正式发行时，我会再来更新这篇文章。\n\n这里要介绍的多数知识你都可以在 [JUnit 5 用户指南][User guide: M2] 中找到（这个链接指向的是先行版 Milestone 2，想看的最新版本文档的话请戳[这里][User guide: Current]），并且指南还有更多的内容等待你发掘。下面的所有代码都可以在 [我的 Github](https://github.com/CodeFX-org/demo-junit-5) 上找到。\n\n## 目录\n\n* JUnit 4 的扩展模型\n    * Runners（运行器）\n    * Rules（规则）\n    * 现状\n* JUnit 5 的扩展模型\n    * 扩展点\n    * 无状态\n    * 应用扩展\n    * 自定义注解\n* 例子\n* 回顾总结\n* 分享&关注\n\n「译者注：本篇的 Runner，统一译为“运行器”；Rule，统一译为“规则”。虽不一定完全达义，但语义未损失太多。在每小节第一次出现处会以中英标注，其后全部使用中文。」\n\n## JUnit 4 的扩展模型\n\n我们先来看看 JUnit 4 中是如何实现扩展的。在 JUnit 4 中实现扩展主要是通过两个，有时也互有重叠的扩展机制：运行器（Runners）和规则（Rules）。\n\n### 运行器（Runners）\n\n[测试运行器](https://github.com/junit-team/junit4/wiki/Test-runners)负责管理诸多测试的生命周期，包括它们的实例化、setup/teardown 方法的调用、测试运行、异常处理、发送消息等。在 JUnit 4 提供的运行器实现中，它负责了这所有的事情。\n\n在 JUnit 4 中，扩展 JUnit 的唯一方法是：创建一个新的运行器，然后使用它标记你新的测试类：`@Runwith(MyRunner.class)`。这样 JUnit 就会识别并使用它来运行测试，而不会使用其默认的实现。\n\n这个方式很重，对于小定制小扩展来说很不方便。同时它有个很苛刻的限制：一个测试类只能用一个运行器来跑，这意味着你不能组合不同的运行器。也即是说，你不能同时享受到两个以上运行器提供的特性，比如说不能同时使用 Mockito 和 Spring 的运行器，等。\n\n### 规则（Rules）\n\n为了克服这个限制，JUnit 4.7 中引入了[规则](https://github.com/junit-team/junit4/wiki/Rules)的概念，它是指测试类中特别的注解字段。 JUnit 4 会把测试方法（与一些其他的行为）包装一层传给规则。规则因此可以在测试代码执行前后插入，执行一些代码。很多时候在测试方法中也会直接调规则类上的方法。\n\n这里有一个例子，展示的是 [temporary folder](http://junit.org/junit4/javadoc/latest/org/junit/rules/TemporaryFolder.html) （临时文件夹）规则：\n\n```java\npublic static class HasTempFolder {\n\t@Rule\n\tpublic TemporaryFolder folder= new TemporaryFolder();\n \n\t@Test\n\tpublic void testUsingTempFolder() throws IOException {\n\t\tFile createdFile= folder.newFile(\"myfile.txt\");\n\t\tFile createdFolder= folder.newFolder(\"subfolder\");\n\t\t// ...\n\t}\n}\n```\n\n因为 `@Rule` 注解的存在，JUnit 会先把测试方法 `testUsingTempFolder` 包装成一个可执行代码块，传给 `folder` 规则。这个规则的作用是执行时， 由 `folder` 创建一个临时目录，执行测试，测试完成后删除临时目录。因此，在测试内部可以放心地在临时目录下创建文件和文件夹。\n\n当然还有其他的规则，比如允许你[在 Swing 的事件分发线程中执行测试](http://blog.schauderhaft.de/2010/08/15/use-cases-for-junit-rules/) 的规则，负责连接和断开数据库的规则，以及[让运行过久的测试直接超时](http://junit.org/junit4/javadoc/latest/org/junit/rules/Timeout.html)的规则等。\n\n规则特性其实已经是个很大的改进了，不过仍有局限，它只能在测试运行之前或之后定制操作。如果你想在此之外的时间点进行扩展，这个特性也无能为力了。\n\n### 现状\n\n总而言之，在 JUnit 4 中存在两种不同的扩展机制，两者均各有局限，并且功能还有重叠的部分。在 JUnit 4 下编写干净的扩展是很难的事。此外，即使你尝试组合两种不同的扩展方式，通常也不会一帆风顺，有时它可能根本不按照开发者期望的方式工作。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/junit-5-extension-model.jpg)\n\n## JUnit 5 的扩展模型\n\nJunit Lambda 项目成立伊始便有几点[核心准则](https://github.com/junit-team/junit5/wiki/Core-Principles)，其中一条便是“扩展点优于新特性”。这个准则其实也就是新版本 JUnit 中最重要的扩展机制了——并非唯一，但无疑是最重要之一。\n\n### 扩展点\n\nJUnit 5 扩展可以声明其主要关注的是测试生命周期的哪部分。JUnit 5 引擎在处理测试时，它会依次检查这些扩展点，并调用每个已注册的扩展。大体来说，这些扩展点出现次序如下：\n\n* 测试类实例 后处理\n* BeforeAll 回调\n* 测试及容器执行条件检查\n* BeforeEach 回调\n* 参数解析\n* 测试执行前\n* 测试执行后\n* 异常处理\n* AfterEach 回调\n* AfterAll 回调\n\n（如果上面有你觉得不甚清晰或理解的点，请不用担心，我们接下来会挑其中的一些来讲解。）\n\n每个扩展点都对应一个接口。接口方法会接受一些参数，一些扩展点所处生命周期的上下文信息。比如，被测实例与方法、测试的名称、参数、注解等信息。\n\n一个扩展可以实现任意个以上的接口方法，引擎会在调用它们时传入相应的上下文信息作为参数。有了这些信息，扩展就可以放心地实现所需的功能了。\n\n### 无状态\n\n这里我们需要考虑一个重要的细节：引擎对扩展实例的初始化时间、实例的生存时间未作出任何规约和保证，因此，扩展必须是无状态的。如果一个扩展需要维持任何状态信息，那么它必须使用 JUnit 提供的一个[仓库（store）](http://junit.org/junit5/docs/5.0.0-M1/api/org/junit/jupiter/api/extension/ExtensionContext.Store.html)来进行信息读取和写入。\n\n这样做的原因有几个：\n\n* 扩展的初始化时机和方式对引擎是未知的（每个测试实例化一次？每个类实例化一次？还是每次运行实例化一次？）。\n* JUnit 不想额外维护和管理每个扩展创建的实例。\n* 如果扩展之间想要进行通信，那么无论如何 JUnit 都必须提供一个数据交互的机制。\n\n### 应用扩展\n\n创建完扩展后，接下来需要做的就仅仅是告诉 JUnit 它的存在。这可以通过在需要使用该扩展的测试类或测试方法上添加一个 `@ExtendWith(MyExtension.class)` 简单实现。\n\n其实，还有另一种更简明的方式。不过要理解那种方式，我们必须先看一下 JUnit 的扩展模型中还有哪些内容。\n\n### 自定义注解\n\n JUnit 5 的 API 大部分是基于注解的，而且引擎在检查注解时还做了些额外的工作：它不仅会查找字段、类、参数上应用的注解，还会注解上的注解。引擎会把找到的所有注解都应用到被注解元素上。注解另一个注解可以通过所谓的[元注解](https://en.wikibooks.org/wiki/Java_Programming/Annotations/Meta-Annotations)做到，酷的是 Junit 提供的所有注解都说得上是元注解了。\n\n它的意义在于，JUnit 5 中我们就能够创建并组合不同的注解了，并且它们具备组合多个注解特性的能力：\n\n```java\n\n/**\n * We define a custom annotation that:\n * - stands in for '@Test' so that the method gets executed\n * - has the tag \"integration\" so we can filter by that,\n *   e.g. when running tests from the command line\n */\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Test\n@Tag(\"integration\")\npublic @interface IntegrationTest { }\n```\n\n这个自定义的“集成测试”注解 `@IntegrationTest` 可以这样使用：\n\n```java\n@IntegrationTest\nvoid runsWithCustomAnnotation() {\n    // this gets executed\n    // even though `@IntegrationTest` is not defined by JUnit\n}\n```\n\n进一步我们可以为扩展使用更简明的注解：\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n@Retention(RetentionPolicy.RUNTIME)\n@ExtendWith(ExternalDatabaseExtension.class)\npublic @interface Database { }\n```\n\n现在我们可以直接使用 `@Database` 注解了，而不需要再声明测试应用了特定的扩展 `@ExtendWith(ExternalDatabaseExtension.class)`。并且由于我们把注解类型 `ElementType.ANNOTATION_TYPE` 也添加到扩展支持的目标类型中去了，因此该注解也可以被我们或他人进一步的使用、组合。\n\n## 例子\n\n假设现在有个场景，我想量化一下测试运行花费的时间。首先，可以先创建一个我们想要的注解：\n\n```java\n@Target({ TYPE, METHOD, ANNOTATION_TYPE })\n@Retention(RetentionPolicy.RUNTIME)\n@ExtendWith(BenchmarkExtension.class)\npublic @interface Benchmark { }\n```\n\n注解声明其应用了 `BenchmarkExtension` 扩展，这是我们接下来要实现的。TODOLIST 如下：\n\n* 计算所有测试类的运行时间，在所有测试执行前保存其起始时间\n* 计算每个测试方法的运行时间，在每个测试方法执行前保存其起始时间\n* 在每个测试方法执行完毕后，获取其结束时间，计算并输出该测试方法的运行时间\n* 在所有测试类执行完毕后，获取其结束时间，计算并输出所有测试的运行时间\n* 以上操作，仅对所有注解了 `@BenchMark` 的测试类或测试方法生效\n\n最后一点需求可能不是一眼便能发现。如果一个方法并未注解 `@Benchmark` 注解，它有什么可能被我们的扩展处理？ 一个语法上的原因是，如果一个扩展被应用到了一个类上，那么它默认也会应用到类中的所有方法上。因此，如果我们的需求是计算整个测试类的运行时间，但不需具体到类中每个单独方法的运行时间时，类中的测试方法就必须被手动排除。这点我们可以通过单独检查每个方法是否应用了注解来做到。\n\n有趣的是，需求的前四点与扩展点中的其中四个是一一对应的：*BeforeAll*、*BeforeTestExecution*、*AfterTestExecution* 与 *AfterAll*。因此我们要做的任务便是实现这四个对应的接口。具体实现很简单，把上面说的翻译成代码即是：\n\n```java\npublic class BenchmarkExtension implements\n\t\tBeforeAllExtensionPoint, BeforeTestExecutionCallback,\n\t\tAfterTestExecutionCallback, AfterAllExtensionPoint {\n \n\tprivate static final Namespace NAMESPACE =\n\t\t\tNamespace.of(\"BenchmarkExtension\");\n \n\t@Override\n\tpublic void beforeAll(ContainerExtensionContext context) {\n\t\tif (!shouldBeBenchmarked(context))\n\t\t\treturn;\n \n\t\twriteCurrentTime(context, LaunchTimeKey.CLASS);\n\t}\n \n\t@Override\n\tpublic void beforeTestExecution(TestExtensionContext context) {\n\t\tif (!shouldBeBenchmarked(context))\n\t\t\treturn;\n \n\t\twriteCurrentTime(context, LaunchTimeKey.TEST);\n\t}\n \n\t@Override\n\tpublic void afterTestExecution(TestExtensionContext context) {\n\t\tif (!shouldBeBenchmarked(context))\n\t\t\treturn;\n \n\t\tlong launchTime = loadLaunchTime(context, LaunchTimeKey.TEST);\n\t\tlong runtime = currentTimeMillis() - launchTime;\n\t\tprint(\"Test\", context.getDisplayName(), runtime);\n\t}\n \n\t@Override\n\tpublic void afterAll(ContainerExtensionContext context) {\n\t\tif (!shouldBeBenchmarked(context))\n\t\t\treturn;\n \n\t\tlong launchTime = loadLaunchTime(context, LaunchTimeKey.CLASS);\n\t\tlong runtime = currentTimeMillis() - launchTime;\n\t\tprint(\"Test container\", context.getDisplayName(), runtime);\n\t}\n \n\tprivate static boolean shouldBeBenchmarked(ExtensionContext context) {\n\t\treturn context.getElement()\n\t\t\t\t.map(el -> el.isAnnotationPresent(Benchmark.class))\n\t\t\t\t.orElse(false);\n\t}\n \n\tprivate static void writeCurrentTime(\n\t\t\tExtensionContext context, LaunchTimeKey key) {\n\t\tcontext.getStore(NAMESPACE).put(key, currentTimeMillis());\n\t}\n \n\tprivate static long loadLaunchTime(\n\t\t\tExtensionContext context, LaunchTimeKey key) {\n\t\treturn (Long) context.getStore(NAMESPACE).remove(key);\n\t}\n \n\tprivate static void print(\n\t\t\tString unit, String displayName, long runtime) {\n\t\tSystem.out.printf(\"%s '%s' took %d ms.%n\", unit, displayName, runtime);\n\t}\n \n\tprivate enum LaunchTimeKey {\n\t\tCLASS, TEST\n\t}\n}\n\n「译者：啊这代码让人心旷神怡。」\n```\n\n上面代码有几个地方值得留意。首先是 `shouldBeBenchmarked` 方法，它使用了 JUnit 的 API 来获取当前元素是否（被元）注解了 `@Benchmark` 注解；其次， `writeCurrentTime` / `loadLaunchTime` 方法中使用了 Junit 提供的 store 以写入和读取运行时间。\n\n[源代码在 Github 上](https://github.com/CodeFX-org/demo-junit-5/tree/master/src/main/java/org/codefx/demo/junit5)可以找到。\n\n下篇博文我会探讨条件执行的测试以及参数注入部分的内容，同时为你展示如何使用其对应的扩展点。如果你已经迫不及待了，那么请先参考[这篇博客](http://www.codeaffine.com/2016/04/06/replace-rules-in-junit5/)，它展示了将应用了两个规则（条件性禁用测试 及 临时目录）的 Junit 4 测试改装成 JUnit 5 测试的方法。\n\n## 总结回顾\n\n通过本文我们了解到，在创建整洁、强大及可组合的扩展上，JUnit 4 提供的运行器和规则特性不够理想。为了超越这些限制，JUnit 5 引入了一个更通用的概念：扩展点。它允许自定义的扩展主动声明，它需要在一个测试的什么节点上去介入。同时，我们还看到如何使用元注解来轻松地自定义注解。\n\n我希望听到你的想法和反馈。\n\n---\n\n[User guide: M2]: http://junit.org/junit5/docs/5.0.0-M2/user-guide/\n[User guide: Current]: http://junit.org/junit5/docs/current/user-guide/\n[JUnit 5: Setup]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-setup\n[JUnit 5: Basics]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-basics\n[JUnit 5: Architecture]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-architecture\n[JUnit 5: Extension Model]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-extension-model\n[JUnit 5: Conditions]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-conditions\n[JUnit 5: Injection]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-injection\n[JUnit 5: Dynamic Tests]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-dynamic-tests\n"},{"id":"2016-09-17-junit5-setup","title":"「译」JUnit 5 系列：环境搭建","contents":"\n\n> 原文地址：[http://blog.codefx.org/libraries/junit-5-setup/](http://blog.codefx.org/libraries/junit-5-setup/)  \n> 原文日期：15, Feb, 2016  \n> 译文首发：[ Linesh 的博客：「译」JUnit 5 系列：环境搭建](http://blog.linesh.tw/#/posts/2016-09-17-junit5-setup)  \n> 我的 Github：[http://github.com/linesh-simplicity](http://github.com/linesh-simplicity)\n\n2015年11月，[Junit Lambda](http://junit.org/junit4/junit-lambda.html) 团队发布了该项目的 [第一版原型](http://blog.codefx.org/libraries/junit-lambda-prototype/) 。此后，该项目把名称改成了 JUnit 5 并独立了出来，随后在2016年2月份的时候发布了一个 alpha 版本。本篇打算以一系列文章，简短地探索一下以下几个方面：\n\n* [环境搭建][JUnit 5: Setup]\n* [基础入门][JUnit 5: Basics]\n* [架构体系][JUnit 5: Architecture]\n* [扩展模型（Extension Model)][JUnit 5: Extension Model]\n* [条件断言][JUnit 5: Conditions]\n* 注入\n* [动态测试][JUnit 5: Dynamic Tests]\n* ...\n\n（如果不喜欢看文章，你可以[戳这里看我的演讲](http://blog.codefx.org/past-talks/)，或者[看一下最近的 vJUG 讲座](https://www.youtube.com/watch?v=ct9sIsrnE9Y)，或者[我在 DevoxxPL 上的 PPT](https://www.youtube.com/watch?v=oG80XZUN1lQ)。\n\n本篇将介绍 JUnit 5 的环境搭建，看完之后你应该能够使用新的 API 来撰写测试，并且使用你喜欢的 IDE 或构建工具来跑这些测试了。\n\n## 概述\n\n本系列文章都基于 Junit 5发布的先行版 [Milestone 2][User guide: M2]。它可能会有变化。如果有新的里程碑（milestone）版本发布，或者试用版正式发行时，我会再来更新这篇文章。\n\n这里要介绍的多数知识你都可以在 [JUnit 5 用户指南][User guide: M2] 中找到（这个链接指向的是先行版 Milestone 2，想看的最新版本文档的话请戳[这里][User guide: Current]），并且指南还有更多的内容等待你发掘。下面的所有代码都可以在 [我的 Github](https://github.com/CodeFX-org/demo-junit-5) 上找到。\n\n## 目录\n\n* 第一个测试\n* 运行测试\n    * 使用 JUnit 4 runner\n    * IDE 的支持\n    * 构建工具的支持\n    * 命令行支持也不赖\n* 向下兼容性\n* 回顾\n* 分享&关注\n\n## 第一个测试\n\n支持测试撰写的 API 包含在` junit-jupiter-api` 包中。在构建工具中引入这个包，就行了。这就是全部，你就可以开始写测试了。\n\n* Group ID: `org.junit.jupiter`\n* Artifact ID: `junit-jupiter-api`\n* Version: `5.0.0-M2`\n\n我们来写[第一个测试](https://github.com/CodeFX-org/demo-junit-5/blob/master/src/test/java/org/codefx/demo/junit5/HelloWorldTest.java)吧，此处简单最好：\n\n```java\npackage org.codefx.demo.junit5;\n \nimport org.junit.jupiter.api.Test;\n \nclass HelloWorldTest {\n \n\t@Test\n\tvoid helloJUnit5() {\n\t\tSystem.out.println(\"Hello, JUnit 5.\");\n\t}\n \n}\n```    \n\n看起来怎样？没 `public` ，感觉帅气不？这里我不会太深入细节讲解，不过[下一篇][JUnit 5: Basics]我会深入讨论下这个（以及其他的一些基础）。请别急，接着往下看。\n\n## 运行测试\n\nJUnit 5 是一代全新的测试框架，不过工具内置的支持则还未完全跟上。好在目前已有简易的方法来运行 JUnit 5 及其测试。\n\n### 使用 JUnit 4 runner\n\nJUnit 团队提供了一个 `JunitPlatform` [runner](http://www.codeaffine.com/2014/09/03/junit-nutshell-test-runners/)，可以使用它在 Junit 4 上运行 JUnit 5 的测试。这个 runner 在另一个包下，因此你也必须将它加入到你的项目中：\n\n* Group ID: `org.junit.platform`\n* Artifact ID: `junit-platform-runner`\n* Version: `1.0.0-M2`\n\n这个 runner 最终会调用 Junit 引擎，后者才是真正运行 Junit 5 测试的部分。引擎也是在不同的包下，你也必须将它加入到项目中：\n\n* Group ID: `org.junit.jupiter`\n* Artifact ID: `junit-jupiter-engine`\n* Version: `5.0.0-M2`\n\n要运行项目中所有的测试，为它们创建一个测试套件是最简单的做法：\n\n```java\n\npackage org.codefx.demo.junit5;\n \nimport org.junit.platform.runner.JUnitPlatform;\nimport org.junit.platform.runner.SelectPackages;\nimport org.junit.runner.RunWith;\n \n@RunWith(JUnitPlatform.class)\n@SelectPackages({ \"org.codefx.demo.junit5\" })\npublic class TestWithJUnit5 { }\n```\n\n不过请注意，这个类必须是一个 JUnit 4 的测试类，也即是说它必须遵循 [一般的命名规范](http://stackoverflow.com/a/6178629/2525313)，并且必须是 `public` 的。`@SelectPackages` 注解会把包当做一个有层级的结构，因此它会负责跑 `org.codefx.demo.junit5` 开头的包下的所有测试。\n\n至此所有工作都完成了！你的 IDE 和构建工具应该都能运行这个 `@RunWith(JUnitPlatform.class)` 注解的测试类了，它会负责跑所有的 JUnit 5 的新测试。\n\n不过在 JUnit 5 被完全支持之前，一些特性可能还不能工作，比如 IDE 无法运行单独的测试等。不过目前为止，这是我发现的最简单并且在多平台下均工作良好的方案了。\n\n### IDE 的支持 \n\nIntellij IDEA [2016.2](https://blog.jetbrains.com/idea/2016/07/intellij-idea-2016-2-is-here/) 开始 [对 JUnit 5 有了基本的支持](https://blog.jetbrains.com/idea/2016/08/using-junit-5-in-intellij-idea)。尽管支持还不是很完美，并且还需时刻关注 JUnit 5 的发展，不过毕竟最基本的支持有了，现在使用 JUnit 5 已经简单得多了。\n\nEclipse 方面团队 [仍在着手于内置支持的开发](https://bugs.eclipse.org/bugs/show_bug.cgi?id=488566)。\n\n### 构建工具的支持\n\nJUnit 团队在为构建工具提供 JUnit 5 支持的基础上已经做了大量的工作，比如提供与 JUnit 4 的兼容等。目前，我们已经有了一个可以工作的 Gradle 插件和 Maven Surefire 插件。这两个项目都计划在接下来的时间里交给各自的社区去开发和维护。\n\n在如何集成这两个构建工具（[Gradle](https://github.com/junit-team/junit5-samples/blob/master/junit5-gradle-consumer)和[Maven](https://github.com/junit-team/junit5-samples/tree/master/junit5-maven-consumer)）的插件上，已经各有一个示例代码库。更多细节请前往 [官方用户指南](http://junit.org/junit5/docs/5.0.0-M1/user-guide/#running-tests-build) 。\n\n### 命令行支持也不赖\n\n如果你觉得你就想静静地跑个测试，上面介绍的 IDE 和构建工具都太复杂了，那么建议你试下这个 [控制台 launcher](http://junit.org/junit5/docs/5.0.0-M1/user-guide/#running-tests-console-launcher)，它支持你直接在命令行运行测试。要使用它，请 [下载这个 zip 包](https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console/1.0.0-M2/junit-platform-console-1.0.0-M2.zip)。\n\n遗憾的是，它 [还需要你做些配置](https://github.com/junit-team/junit5/issues/155)，而非拿来即用的。你需要将上面提到的两个包 `junit-jupiter-api` 和 `junit-jupiter-engine` 移动到 `lib` 目录下，并编辑 `bin` 下执行脚本的 classpath 使其指向你的 `lib` 目录：`CLASSPATH=$APP_HOEM/lib/*`。这样该 launcher 才能运行。\n\n不考虑其他依赖的话，这个执行脚本大概长得像这样：\n\n```bash\n# run all tests\njunit-platform-console -p ${path_to_compiled_test_classes} -a\n# run a specific test\njunit-platform-console\n\t-p ${path_to_compiled_test_classes}\n\torg.codefx.demo.junit5.HelloWorldTest\n```\n\n## 向下兼容性\n\n你可能注意到了，JUnit 5 启用了新的包名：`org.junit.jupiter`、`org.junit.platform` 和 `org.junit.vintage` （这个包我们尚未谈到）。我们[待会][JUnit 5: Architecture]再讨论它们的含义，现在我们只需知道，这意味着你可以在一个项目中使用不同的 JUnit 版本，这就够了。\n\n允许在同个项目中使用多个版本的 JUnit 来进行测试，这使得你能缓缓迁移到 JUnit 5上。关于迁移，我们在探讨 [JUnit 新的架构][JUnit 5: Architecture] 时会再回顾这个话题。\n\n通过异常（exceptions）于 JUnit 交互的测试库，诸如 Hamcrest 和 AssertJ 等，易燃可以在 JUnit 的新版本下工作。这里有个使用 Mockito 和 AssertJ 写的 [`HelloWorldTest`](https://github.com/CodeFX-org/demo-junit-5/blob/master/src/test/java/org/codefx/demo/junit5/HelloWorldTest.java) 测试，有兴趣的同学可以看下。\n\n## 回顾\n\n在这篇 JUnit 5 环境搭建的文章中，我们介绍了 `junit-jupiter-api` 和 `junit-jupiter-engine` 两个包，在项目中使用了 `junit-platform-runner` ，写了第一个最简单的测试用例，并将它作为 JUnit 4 测试套件的一部分运行了起来。\n\n[下篇文章][JUnit 5: Basics] 我会讨论使用 JUnit 5 撰写测试的一些基础知识。\n\n\n[User guide: M2]: http://junit.org/junit5/docs/5.0.0-M2/user-guide/\n[User guide: Current]: http://junit.org/junit5/docs/current/user-guide/\n[JUnit 5: Setup]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-setup\n[JUnit 5: Basics]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-basics\n[JUnit 5: Architecture]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-architecture\n[JUnit 5: Extension Model]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-extension-model\n[JUnit 5: Conditions]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-conditions\n[JUnit 5: Injection]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-injection\n[JUnit 5: Dynamic Tests]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-dynamic-tests\n"}]