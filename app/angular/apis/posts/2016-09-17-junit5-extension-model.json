{"id":"2016-09-17-junit5-extension-model","title":"「译」JUnit 5 系列：扩展模型（Extension Model）","contents":"\n\n> 原文地址：[http://blog.codefx.org/design/architecture/junit-5-extension-model/](http://blog.codefx.org/design/architecture/junit-5-extension-model/)  \n> 原文日期：11, Apr, 2016  \n> 译文首发：[ Linesh 的博客：「译」JUnit 5 系列：扩展模型（Extension Model）](http://blog.linesh.tw/#/posts/2016-09-17-junit5-extension-model)  \n> 我的 Github：[http://github.com/linesh-simplicity](http://github.com/linesh-simplicity)\n\n## 概述\n\n* [环境搭建][JUnit 5: Setup]\n* [基础入门][JUnit 5: Basics]\n* [架构体系][JUnit 5: Architecture]\n* [扩展模型（Extension Model)][JUnit 5: Extension Model]\n* [条件断言][JUnit 5: Conditions]\n* 注入\n* [动态测试][JUnit 5: Dynamic Tests]\n* ...\n\n（如果不喜欢看文章，你可以[戳这里看我的演讲](http://blog.codefx.org/past-talks/)，或者[看一下最近的 vJUG 讲座](https://www.youtube.com/watch?v=ct9sIsrnE9Y)，或者[我在 DevoxxPL 上的 PPT](https://www.youtube.com/watch?v=oG80XZUN1lQ)。\n\n本系列文章都基于 Junit 5发布的先行版 [Milestone 2][User guide: M2]。它可能会有变化。如果有新的里程碑（milestone）版本发布，或者试用版正式发行时，我会再来更新这篇文章。\n\n这里要介绍的多数知识你都可以在 [JUnit 5 用户指南][User guide: M2] 中找到（这个链接指向的是先行版 Milestone 2，想看的最新版本文档的话请戳[这里][User guide: Current]），并且指南还有更多的内容等待你发掘。下面的所有代码都可以在 [我的 Github](https://github.com/CodeFX-org/demo-junit-5) 上找到。\n\n## 目录\n\n* JUnit 4 的扩展模型\n    * Runners（运行器）\n    * Rules（规则）\n    * 现状\n* JUnit 5 的扩展模型\n    * 扩展点\n    * 无状态\n    * 应用扩展\n    * 自定义注解\n* 例子\n* 回顾总结\n* 分享&关注\n\n「译者注：本篇的 Runner，统一译为“运行器”；Rule，统一译为“规则”。虽不一定完全达义，但语义未损失太多。在每小节第一次出现处会以中英标注，其后全部使用中文。」\n\n## JUnit 4 的扩展模型\n\n我们先来看看 JUnit 4 中是如何实现扩展的。在 JUnit 4 中实现扩展主要是通过两个，有时也互有重叠的扩展机制：运行器（Runners）和规则（Rules）。\n\n### 运行器（Runners）\n\n[测试运行器](https://github.com/junit-team/junit4/wiki/Test-runners)负责管理诸多测试的生命周期，包括它们的实例化、setup/teardown 方法的调用、测试运行、异常处理、发送消息等。在 JUnit 4 提供的运行器实现中，它负责了这所有的事情。\n\n在 JUnit 4 中，扩展 JUnit 的唯一方法是：创建一个新的运行器，然后使用它标记你新的测试类：`@Runwith(MyRunner.class)`。这样 JUnit 就会识别并使用它来运行测试，而不会使用其默认的实现。\n\n这个方式很重，对于小定制小扩展来说很不方便。同时它有个很苛刻的限制：一个测试类只能用一个运行器来跑，这意味着你不能组合不同的运行器。也即是说，你不能同时享受到两个以上运行器提供的特性，比如说不能同时使用 Mockito 和 Spring 的运行器，等。\n\n### 规则（Rules）\n\n为了克服这个限制，JUnit 4.7 中引入了[规则](https://github.com/junit-team/junit4/wiki/Rules)的概念，它是指测试类中特别的注解字段。 JUnit 4 会把测试方法（与一些其他的行为）包装一层传给规则。规则因此可以在测试代码执行前后插入，执行一些代码。很多时候在测试方法中也会直接调规则类上的方法。\n\n这里有一个例子，展示的是 [temporary folder](http://junit.org/junit4/javadoc/latest/org/junit/rules/TemporaryFolder.html) （临时文件夹）规则：\n\n```java\npublic static class HasTempFolder {\n\t@Rule\n\tpublic TemporaryFolder folder= new TemporaryFolder();\n \n\t@Test\n\tpublic void testUsingTempFolder() throws IOException {\n\t\tFile createdFile= folder.newFile(\"myfile.txt\");\n\t\tFile createdFolder= folder.newFolder(\"subfolder\");\n\t\t// ...\n\t}\n}\n```\n\n因为 `@Rule` 注解的存在，JUnit 会先把测试方法 `testUsingTempFolder` 包装成一个可执行代码块，传给 `folder` 规则。这个规则的作用是执行时， 由 `folder` 创建一个临时目录，执行测试，测试完成后删除临时目录。因此，在测试内部可以放心地在临时目录下创建文件和文件夹。\n\n当然还有其他的规则，比如允许你[在 Swing 的事件分发线程中执行测试](http://blog.schauderhaft.de/2010/08/15/use-cases-for-junit-rules/) 的规则，负责连接和断开数据库的规则，以及[让运行过久的测试直接超时](http://junit.org/junit4/javadoc/latest/org/junit/rules/Timeout.html)的规则等。\n\n规则特性其实已经是个很大的改进了，不过仍有局限，它只能在测试运行之前或之后定制操作。如果你想在此之外的时间点进行扩展，这个特性也无能为力了。\n\n### 现状\n\n总而言之，在 JUnit 4 中存在两种不同的扩展机制，两者均各有局限，并且功能还有重叠的部分。在 JUnit 4 下编写干净的扩展是很难的事。此外，即使你尝试组合两种不同的扩展方式，通常也不会一帆风顺，有时它可能根本不按照开发者期望的方式工作。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/junit-5-extension-model.jpg)\n\n## JUnit 5 的扩展模型\n\nJunit Lambda 项目成立伊始便有几点[核心准则](https://github.com/junit-team/junit5/wiki/Core-Principles)，其中一条便是“扩展点优于新特性”。这个准则其实也就是新版本 JUnit 中最重要的扩展机制了——并非唯一，但无疑是最重要之一。\n\n### 扩展点\n\nJUnit 5 扩展可以声明其主要关注的是测试生命周期的哪部分。JUnit 5 引擎在处理测试时，它会依次检查这些扩展点，并调用每个已注册的扩展。大体来说，这些扩展点出现次序如下：\n\n* 测试类实例 后处理\n* BeforeAll 回调\n* 测试及容器执行条件检查\n* BeforeEach 回调\n* 参数解析\n* 测试执行前\n* 测试执行后\n* 异常处理\n* AfterEach 回调\n* AfterAll 回调\n\n（如果上面有你觉得不甚清晰或理解的点，请不用担心，我们接下来会挑其中的一些来讲解。）\n\n每个扩展点都对应一个接口。接口方法会接受一些参数，一些扩展点所处生命周期的上下文信息。比如，被测实例与方法、测试的名称、参数、注解等信息。\n\n一个扩展可以实现任意个以上的接口方法，引擎会在调用它们时传入相应的上下文信息作为参数。有了这些信息，扩展就可以放心地实现所需的功能了。\n\n### 无状态\n\n这里我们需要考虑一个重要的细节：引擎对扩展实例的初始化时间、实例的生存时间未作出任何规约和保证，因此，扩展必须是无状态的。如果一个扩展需要维持任何状态信息，那么它必须使用 JUnit 提供的一个[仓库（store）](http://junit.org/junit5/docs/5.0.0-M1/api/org/junit/jupiter/api/extension/ExtensionContext.Store.html)来进行信息读取和写入。\n\n这样做的原因有几个：\n\n* 扩展的初始化时机和方式对引擎是未知的（每个测试实例化一次？每个类实例化一次？还是每次运行实例化一次？）。\n* JUnit 不想额外维护和管理每个扩展创建的实例。\n* 如果扩展之间想要进行通信，那么无论如何 JUnit 都必须提供一个数据交互的机制。\n\n### 应用扩展\n\n创建完扩展后，接下来需要做的就仅仅是告诉 JUnit 它的存在。这可以通过在需要使用该扩展的测试类或测试方法上添加一个 `@ExtendWith(MyExtension.class)` 简单实现。\n\n其实，还有另一种更简明的方式。不过要理解那种方式，我们必须先看一下 JUnit 的扩展模型中还有哪些内容。\n\n### 自定义注解\n\n JUnit 5 的 API 大部分是基于注解的，而且引擎在检查注解时还做了些额外的工作：它不仅会查找字段、类、参数上应用的注解，还会注解上的注解。引擎会把找到的所有注解都应用到被注解元素上。注解另一个注解可以通过所谓的[元注解](https://en.wikibooks.org/wiki/Java_Programming/Annotations/Meta-Annotations)做到，酷的是 Junit 提供的所有注解都说得上是元注解了。\n\n它的意义在于，JUnit 5 中我们就能够创建并组合不同的注解了，并且它们具备组合多个注解特性的能力：\n\n```java\n\n/**\n * We define a custom annotation that:\n * - stands in for '@Test' so that the method gets executed\n * - has the tag \"integration\" so we can filter by that,\n *   e.g. when running tests from the command line\n */\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Test\n@Tag(\"integration\")\npublic @interface IntegrationTest { }\n```\n\n这个自定义的“集成测试”注解 `@IntegrationTest` 可以这样使用：\n\n```java\n@IntegrationTest\nvoid runsWithCustomAnnotation() {\n    // this gets executed\n    // even though `@IntegrationTest` is not defined by JUnit\n}\n```\n\n进一步我们可以为扩展使用更简明的注解：\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n@Retention(RetentionPolicy.RUNTIME)\n@ExtendWith(ExternalDatabaseExtension.class)\npublic @interface Database { }\n```\n\n现在我们可以直接使用 `@Database` 注解了，而不需要再声明测试应用了特定的扩展 `@ExtendWith(ExternalDatabaseExtension.class)`。并且由于我们把注解类型 `ElementType.ANNOTATION_TYPE` 也添加到扩展支持的目标类型中去了，因此该注解也可以被我们或他人进一步的使用、组合。\n\n## 例子\n\n假设现在有个场景，我想量化一下测试运行花费的时间。首先，可以先创建一个我们想要的注解：\n\n```java\n@Target({ TYPE, METHOD, ANNOTATION_TYPE })\n@Retention(RetentionPolicy.RUNTIME)\n@ExtendWith(BenchmarkExtension.class)\npublic @interface Benchmark { }\n```\n\n注解声明其应用了 `BenchmarkExtension` 扩展，这是我们接下来要实现的。TODOLIST 如下：\n\n* 计算所有测试类的运行时间，在所有测试执行前保存其起始时间\n* 计算每个测试方法的运行时间，在每个测试方法执行前保存其起始时间\n* 在每个测试方法执行完毕后，获取其结束时间，计算并输出该测试方法的运行时间\n* 在所有测试类执行完毕后，获取其结束时间，计算并输出所有测试的运行时间\n* 以上操作，仅对所有注解了 `@BenchMark` 的测试类或测试方法生效\n\n最后一点需求可能不是一眼便能发现。如果一个方法并未注解 `@Benchmark` 注解，它有什么可能被我们的扩展处理？ 一个语法上的原因是，如果一个扩展被应用到了一个类上，那么它默认也会应用到类中的所有方法上。因此，如果我们的需求是计算整个测试类的运行时间，但不需具体到类中每个单独方法的运行时间时，类中的测试方法就必须被手动排除。这点我们可以通过单独检查每个方法是否应用了注解来做到。\n\n有趣的是，需求的前四点与扩展点中的其中四个是一一对应的：*BeforeAll*、*BeforeTestExecution*、*AfterTestExecution* 与 *AfterAll*。因此我们要做的任务便是实现这四个对应的接口。具体实现很简单，把上面说的翻译成代码即是：\n\n```java\npublic class BenchmarkExtension implements\n\t\tBeforeAllExtensionPoint, BeforeTestExecutionCallback,\n\t\tAfterTestExecutionCallback, AfterAllExtensionPoint {\n \n\tprivate static final Namespace NAMESPACE =\n\t\t\tNamespace.of(\"BenchmarkExtension\");\n \n\t@Override\n\tpublic void beforeAll(ContainerExtensionContext context) {\n\t\tif (!shouldBeBenchmarked(context))\n\t\t\treturn;\n \n\t\twriteCurrentTime(context, LaunchTimeKey.CLASS);\n\t}\n \n\t@Override\n\tpublic void beforeTestExecution(TestExtensionContext context) {\n\t\tif (!shouldBeBenchmarked(context))\n\t\t\treturn;\n \n\t\twriteCurrentTime(context, LaunchTimeKey.TEST);\n\t}\n \n\t@Override\n\tpublic void afterTestExecution(TestExtensionContext context) {\n\t\tif (!shouldBeBenchmarked(context))\n\t\t\treturn;\n \n\t\tlong launchTime = loadLaunchTime(context, LaunchTimeKey.TEST);\n\t\tlong runtime = currentTimeMillis() - launchTime;\n\t\tprint(\"Test\", context.getDisplayName(), runtime);\n\t}\n \n\t@Override\n\tpublic void afterAll(ContainerExtensionContext context) {\n\t\tif (!shouldBeBenchmarked(context))\n\t\t\treturn;\n \n\t\tlong launchTime = loadLaunchTime(context, LaunchTimeKey.CLASS);\n\t\tlong runtime = currentTimeMillis() - launchTime;\n\t\tprint(\"Test container\", context.getDisplayName(), runtime);\n\t}\n \n\tprivate static boolean shouldBeBenchmarked(ExtensionContext context) {\n\t\treturn context.getElement()\n\t\t\t\t.map(el -> el.isAnnotationPresent(Benchmark.class))\n\t\t\t\t.orElse(false);\n\t}\n \n\tprivate static void writeCurrentTime(\n\t\t\tExtensionContext context, LaunchTimeKey key) {\n\t\tcontext.getStore(NAMESPACE).put(key, currentTimeMillis());\n\t}\n \n\tprivate static long loadLaunchTime(\n\t\t\tExtensionContext context, LaunchTimeKey key) {\n\t\treturn (Long) context.getStore(NAMESPACE).remove(key);\n\t}\n \n\tprivate static void print(\n\t\t\tString unit, String displayName, long runtime) {\n\t\tSystem.out.printf(\"%s '%s' took %d ms.%n\", unit, displayName, runtime);\n\t}\n \n\tprivate enum LaunchTimeKey {\n\t\tCLASS, TEST\n\t}\n}\n\n「译者：啊这代码让人心旷神怡。」\n```\n\n上面代码有几个地方值得留意。首先是 `shouldBeBenchmarked` 方法，它使用了 JUnit 的 API 来获取当前元素是否（被元）注解了 `@Benchmark` 注解；其次， `writeCurrentTime` / `loadLaunchTime` 方法中使用了 Junit 提供的 store 以写入和读取运行时间。\n\n[源代码在 Github 上](https://github.com/CodeFX-org/demo-junit-5/tree/master/src/main/java/org/codefx/demo/junit5)可以找到。\n\n下篇博文我会探讨条件执行的测试以及参数注入部分的内容，同时为你展示如何使用其对应的扩展点。如果你已经迫不及待了，那么请先参考[这篇博客](http://www.codeaffine.com/2016/04/06/replace-rules-in-junit5/)，它展示了将应用了两个规则（条件性禁用测试 及 临时目录）的 Junit 4 测试改装成 JUnit 5 测试的方法。\n\n## 总结回顾\n\n通过本文我们了解到，在创建整洁、强大及可组合的扩展上，JUnit 4 提供的运行器和规则特性不够理想。为了超越这些限制，JUnit 5 引入了一个更通用的概念：扩展点。它允许自定义的扩展主动声明，它需要在一个测试的什么节点上去介入。同时，我们还看到如何使用元注解来轻松地自定义注解。\n\n我希望听到你的想法和反馈。\n\n---\n\n[User guide: M2]: http://junit.org/junit5/docs/5.0.0-M2/user-guide/\n[User guide: Current]: http://junit.org/junit5/docs/current/user-guide/\n[JUnit 5: Setup]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-setup\n[JUnit 5: Basics]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-basics\n[JUnit 5: Architecture]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-architecture\n[JUnit 5: Extension Model]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-extension-model\n[JUnit 5: Conditions]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-conditions\n[JUnit 5: Injection]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-injection\n[JUnit 5: Dynamic Tests]: http://blog.linesh.tw/#/posts/2016-09-17-junit5-dynamic-tests\n"}